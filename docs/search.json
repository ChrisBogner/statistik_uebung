[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "√úbung zur Vorlesung Statistik und Datenanalyse",
    "section": "",
    "text": "Vorwort\nIn dieser Veranstaltung werden wir folgende Werkzeuge verwenden:\nILIAS: die Online-Lernplattform der UzK. Sie sollten alle bereits registriert sein.\nCampuswire: die Chatplattform dient der allgemeinen Kommunikation und der Selbstorganisation des Lernens. Verwenden Sie diese, um Fragen mit Ihren Kommilitonen*innen und mir zu diskutieren. Sie sollten eine Einladungsmail zu Campuswire erhalten haben.\nZoom: die Videokonferenz-Software bleibt unser Notfall-Werkzeug, falls keine Pr√§senz m√∂glich ist."
  },
  {
    "objectID": "01-einfuehrung.html",
    "href": "01-einfuehrung.html",
    "title": "1¬† Die √úbung",
    "section": "",
    "text": "Note\n\n\n\n\nDaten f√ºr Analysen vorbereiten\nDaten einlesen und visualisieren\nCode und Dokumentation in R Markdown schreiben\neigene Funktionen schreiben\nreproduzierbare Datenanalysen durchf√ºhren\ngelernte Methoden auf einen neuen Datensatz anwenden\nErgebnisse reproduzierbar im Praktikumsbericht darstellen"
  },
  {
    "objectID": "01-einfuehrung.html#lernziele-des-kurses",
    "href": "01-einfuehrung.html#lernziele-des-kurses",
    "title": "1¬† Der Kurs",
    "section": "Lernziele des Kurses",
    "text": "Lernziele des Kurses\n\n\n\n\n\n\nNote\n\n\n\n\nDaten f√ºr Analysen vorbereiten\nDaten einlesen und visualisieren\nCode und Dokumentation in R Markdown schreiben\neigene Funktionen schreiben\nreproduzierbare Datenanalysen durchf√ºhren\ngelernte Methoden auf einen neuen Datensatz anwenden\nErgebnisse reproduzierbar im Praktikumsbericht darstellen"
  },
  {
    "objectID": "01-einfuehrung.html#was-mir-im-umgang-miteinander-wichtig-ist",
    "href": "01-einfuehrung.html#was-mir-im-umgang-miteinander-wichtig-ist",
    "title": "1¬† Die √úbung",
    "section": "Was mir im Umgang miteinander wichtig ist",
    "text": "Was mir im Umgang miteinander wichtig ist\n\nP√ºnktlichkeit bei Pr√§senz- und Zoomsitzungen\nGute Vorbereitung durch Erledigen der Hausaufgaben\nRespektieren anderer Meinungen\nOffenheit gegen√ºber neuen Sichtweisen, Themen und Methoden\nGeduld mit sich selbst und den anderen üòÑ"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literatur",
    "section": "",
    "text": "√áetinkaya-Rundel, Mine, and Johanna Hardin. 2022. Introduction to\nModern Statistics. https://openintro-ims.netlify.app/.\n\n\nIhaka, Ross, and Robert Gentleman. 1996. ‚ÄúR: A\nLanguage for Data Analysis and\nGraphics.‚Äù Journal of Computational and\nGraphical Statistics 5 (3): 299‚Äì314. https://doi.org/10.1080/10618600.1996.10474713.\n\n\nIsmay, Chester, and Albert Y. Kim. 2021. ModernDive:\nStatistical Inference via Data Science.\nhttps://moderndive.com/.\n\n\nKnuth, D. E. 1984. ‚ÄúLiterate Programming.‚Äù\nThe Computer Journal 27 (2): 97‚Äì111. https://doi.org/10.1093/comjnl/27.2.97.\n\n\nWickham, Hadley. 2020. Ggplot2: Elegant Graphics for\nData Analysis. 3rd, in progress.\n\n\nWickham, Hadley, and Garrett Grolemund. 2021. R for Data\nScience. https://r4ds.had.co.nz/.\n\n\nXie, Yihui, J. J. Allaire, and Garrett Grolemund. 2021. R\nMarkdown: The Definitive Guide. https://bookdown.org/yihui/rmarkdown/.\n\n\nZuur, A. F., E. Ieno, and E. Meesters. 2009. A Beginner‚Äôs Guide to\nR. Springer."
  },
  {
    "objectID": "01-erste-schritte.html",
    "href": "01-erste-schritte.html",
    "title": "1¬† Erste Schritte in R",
    "section": "",
    "text": "‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.1 ‚îÄ‚îÄ\n\n\n‚úî ggplot2 3.3.6     ‚úî purrr   0.3.4\n‚úî tibble  3.1.7     ‚úî dplyr   1.0.9\n‚úî tidyr   1.2.0     ‚úî stringr 1.4.0\n‚úî readr   2.1.2     ‚úî forcats 0.5.1\n\n\n‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n‚úñ dplyr::filter() masks stats::filter()\n‚úñ dplyr::lag()    masks stats::lag()\n\n\n\nAttache Paket: 'kableExtra'\n\n\nDas folgende Objekt ist maskiert 'package:dplyr':\n\n    group_rows"
  },
  {
    "objectID": "01-erste-schritte.html#was-ist",
    "href": "01-erste-schritte.html#was-ist",
    "title": "1¬† Erste Schritte in R",
    "section": "1.1 Was ist ?",
    "text": "1.1 Was ist ?\nR ist eine Programmiersprache f√ºr Datenanalyse und statistische Modellierung. Es ist frei verf√ºgbar (open source software) und neben Python einer der am meisten benutzten Programmiersprachen zur Datenanalyse und -visualisierung. R wurde von Ross Ihaka und Robert Gentleman 1996 ver√∂ffentlicht (Ihaka and Gentleman 1996). Es gibt f√ºr R eine Vielzahl von Zusatzpaketen, die die Funktionalit√§t und die Einsatzm√∂glichkeiten enorm erweitern.\nSie k√∂nnen R f√ºr Ihren Computer auf der offiziellen R-Seite https://www.r-project.org/ herunterladen und installieren. Eine kurze Anleitung finden Sie auf ILIAS, zusammen mit der Liste der Pakete, die wir in diesm Kurs brachen werden. Zus√§tzlich k√∂nnen Sie sich hier ein Video zur Installation ansehen.\nAuf der offiziellen R-Seite finden Sie auch zus√§tzliche Pakete, und zwar unter CRAN (The Comprehensive R Archive Network). Manche Pakete sind auf den CRAN-Seiten thematische in sogen. CRAN Task Views gegliedert. F√ºr den Umweltbereich sind folgende Paketsammlungen besonders relevant:\n\nEnvironmetrics: Analyse von Umweltdaten\nMultivariate: Multivariate Statistik\nSpatial: Analyse von r√§umlichen Daten\nTimeSeries: Zeitreihenanalyse\n\nZu Beginn des Kurses werden wir jedoch nicht auf Ihren lokalen Rechnern arbeiten, sondern auf den bereits eingerichteten Uni-Rechnern in den EDV-R√§umen. Daher biete ich zu diesem fr√ºhen Zeitpunkt im Kurs keine Unterst√ºtzung bei der Installation von R auf Ihren Privatrechnern. F√ºr die ganz Ungeduldigen, gibt es hier eine kurze Einleitung zur Installation."
  },
  {
    "objectID": "01-erste-schritte.html#was-ist-rstudio",
    "href": "01-erste-schritte.html#was-ist-rstudio",
    "title": "1¬† Erste Schritte in R",
    "section": "1.2 Was ist RStudio?",
    "text": "1.2 Was ist RStudio?\nRStudio Desktop ist eine Entwicklungsumgebung f√ºr R. Wichtig: RStudio wird erst nach R installiert und macht ohne R keinen Sinn. Sie k√∂nnen die open source Version kostenlos f√ºr Ihren Rechner hier herunterladen, falls Sie sich entscheiden, (sp√§ter) R auf Ihrem Rechner zu installieren. Es gibt eine live Einf√ºhrung in RStudio im Kurs. Zus√§tzlich k√∂nnen Sie hier ein Video dazu ansehen.\nDie Oberfl√§che von RStudio ist in vier Bereiche unterteilt (Figure¬†1.1).\n\n\n\nFigure¬†1.1: Aufbau von RStudio\n\n\nSie sollten auch auf Ihrem eigenen Rechner einen Ordner f√ºr die Veranstaltung anlegen und darin jeweils einen Ordner f√ºr Folien, Daten und Notebooks."
  },
  {
    "objectID": "01-erste-schritte.html#lesestoff",
    "href": "01-erste-schritte.html#lesestoff",
    "title": "1¬† Erste Schritte in R",
    "section": "1.3 Lesestoff",
    "text": "1.3 Lesestoff\nKapitel 1.1 und 1.2 in Ismay and Kim (2021)."
  },
  {
    "objectID": "01-erste-schritte.html#aufgaben",
    "href": "01-erste-schritte.html#aufgaben",
    "title": "1¬† Erste Schritte in R",
    "section": "1.4 Aufgaben",
    "text": "1.4 Aufgaben\n\nBitte speichern Sie Ihr Skript regelm√§√üig ab!\n\n\n1.4.1 R als Taschenrechner\nR ist ein gro√üer Taschenrechner mit vielen bereits definierten Funktionen. Es gelten die √ºblichen Rechenregeln wie z.B. Punkt-vor-Strich und die Klammern.\n\nSchreiben Sie den Code, der 2 und 10 addiert\n\nDas korrekte Multiplikationszeichen in R ist *.\n\nGeben Sie den folgenden Befehl korrekt in R ein: (2 + 10) \\(\\times\\) 27\n\nBei Dezimalzahlen wird der Dezimalpunkt und nicht das Komma verwendet. Das ist wichtig zu beachten, wenn Sie sp√§ter Daten in R einlesen m√∂chten.\n\nBerechnen Sie die Summe von 2,34 und 4,98.\n\n\n\n1.4.2 Zuweisungen\nIn R arbeitet man mit Objekten. Ein Objekt kann alles M√∂gliche sein: eine Variable, Daten, Vektoren etc. Wenn also das Ergebnis einer Berechnung oder ein Datenobjekt im R-Arbeitsbereich (workspace) zur Verf√ºgung stehen soll, muss daraus ein Objekt erstellt werden.\nObjekte erstellt man, indem man ihnen Namen gibt. Diesen Vorgang nennt man Zuweisung (assignment). Im Beispiel unten wird ein Objekt, in diesem Fall ein Skalar, namens x erzeugt, mit dem Wert 42. Um den Wert von x anzuzeigen, tippen Sie x ein.\n\nx <- 42\n\n# Zeige den Wert von x\nx\n\nZuweisungen k√∂nnen in R entweder mit dem = erfolgen oder mit <-. Beide Varianten sind gleichwertig. Dabei ist allerdings Pfeilrichtung entscheidend! x <- 42 bedeutet: Die linke Seite (Zahl 42) wird dem Objekt x zugeordnet. Wenn man die Pfeilrichtung umdreht, macht die Zuweisung keinen Sinn und man erh√§lt eine Fehlermeldung.\n\n# Sinnvolle Zuweisung\nx <- 42\n# Gleichwertige sinnvolle Zuweisung\nx = 42\n# Sinnloser Ausdruck. Fehlermeldung!\nx -> 42\n\nError in 42 <- x: ung√ºltige (do_set) linke Seite in Zuweisung\n\n\nObjektnamen k√∂nnen (fast) frei gew√§hlt werden. Sie m√ºssen mit einem Buchstaben beginnen und d√ºrfen keine Sonderzeichen enthalten. Bei l√§ngeren Namen empfiehlt sich ein _. Streng verboten sind Namen von vordefinierten Funktionen!\n\nErstellen Sie ein Objekt namens mein_objekt und weisen Sie ihm das Ergebnis der Berechnung \\(23^{2}\\) zu. Eine Potenz berechnen Sie mit ^.\n\nEine Zuweisung kann auch kompliziertere Anweisungen enthalten. Hier erstellen wir z.B. einen Vektor mithilfe der Funktion c (concatenate) und weisen das Ergebnis dem Objekt my_a zu.\n\nmy_a <- c(32, 54, 1.2, 398)\n\n\n\n1.4.3 Funktionsaufruf\nIn R gibt es eine Vielzahl von vordefinierten Funktionen. Ein Funktionsaufruf hat immer die gleiche Form: mach_das(damit) oder mach_das(damit, und_mit_dieser_einstellung). Z.B. wird die Summe auf einem Objekt mein_objekt mit sum(mein_objekt) berechnet.\n\nErstellen Sie einen Vektor mit den Zahlen 32, 54, 1,2 und 398 und weisen Sie ihn der Variablen my_a zu.\nBerechnen Sie die summe von my_a.\n\nSie k√∂nnen im √úbrigen auch Vektoren sinnvoll addieren.\n\nErstellen Sie einen Vektor my_b mit der passenden L√§nge und addieren Sie ihn zum Vektor my_a. Die Addition erfolgt elementweise.\n\nH√§ufig wollen wir f√ºr unsere Daten den Mittelwert berechnen.\n\nBerechnen Sie den Mittelwert von my_a\nBerechnen Sie die Standardabweichung von my_a.\n\n\n\n1.4.4 Objekte ansprechen\nUm das ‚ÄúInnenleben‚Äù der Objekte in R anzusprechen, gibt es verschieden M√∂glichkeiten. In diesem Tutorial konzentrieren wir uns auf Vektoren. Um die einzelnen Komponenten im Vektor anzusprechen, benutzt man eckige Klammern [ ]. Um eine bestimmte Komponente zu adressieren (anzusprechen), schreibt man die Platznummer der Komponente in die Klammer. Wenn man im Vektor my_c, z.B. die dritte Komponente extrahieren m√∂chte, dann schreibt man my_c[3]\n\nmy_c <- c(2, 45.7, pi, sqrt(23), 2^6)\nmy_c[3]\n\nWir k√∂nnen auch Vektoren erstellen, bei denen einzelne Elemente benannt sind.\n\nbenannt <- c('Koeln' = 50667, 'Berlin' = 10965, \"Stuttgart\" = 70173)\n\nElemente in solchen Vektoren kann man mit Namen in eckigen Klammern ansprechen. Die Namen m√ºssen in Anf√ºhrungszeichen geschrieben werden. Es spielt keine Rolle, ob Sie einfache oder doppelte Anf√ºhrungszeichen benutzen.\n\nFragen Sie nach dem Element Koeln im Vektor benannt.\n\n\n\n1.4.5 Ars Haushaltsbuch\nDer angehende Datenanalyst Ar Stat m√∂chte dem Rat seiner Mutter folgen und ein Haushaltsbuch anlegen. Zuerst m√∂chte er sich einen √úberblick √ºber seine Ausgaben in der Uni-Mensa verschaffen und erstellt die folgende Tabelle:\n\n\n\nArs Mensaausgaben\n \n  \n    Wochentag \n    Ausgaben (‚Ç¨) \n  \n \n\n  \n    Montag \n    2,57 \n  \n  \n    Dienstag \n    2,90 \n  \n  \n    Mittwoch \n    2,73 \n  \n  \n    Donnerstag \n    3,23 \n  \n  \n    Freitag \n    3,90 \n  \n\n\n\n\n\nWie viel hat Ar insgesamt in der Woche ausgegeben?\nWie gro√ü ist die Differenz zwischen dem h√∂chsten und dem niedrigsten Betrag?\nWie viel h√§tte er insgesamt ausgegeben, wenn er jeden Tag so viel gezahlt h√§tte, wie am Dienstag. Wichtig: Verwenden Sie die [], um den Betrag von Dienstag auszuw√§hlen!\n\nLeider hat Ar sich beim √úbertragen der Daten vertippt. Er hat am Dienstag seine Freundin zum Essen eingeladen und 7,95 ‚Ç¨ statt 2,90 ‚Ç¨ ausgegeben.\n\nKorrigieren Sie Ars Fehler.\nWie ver√§ndern sich die Ergebnisse aus den Teilaufgaben 1 bis 3?\n\n\n\n1.4.6 Fehlende Werte\nR kodiert fehlende Werte mit NA. Ar Stat hat am Montag der darauffolgenden Woche in der Mensa gegessen, aber vergessen die Ausgaben zu notieren.\n\n\n\nArs Mensaausgaben, cont.\n \n  \n    Wochentag \n    Amount spent (‚Ç¨) \n  \n \n\n  \n    Montag, 9. M√§rz \n    2,57 \n  \n  \n    Dienstag, 10. M√§rz \n    2,90 \n  \n  \n    Mittwoch, 11. M√§rz \n    2,73 \n  \n  \n    Donnerstag, 12. M√§rz \n    3,23 \n  \n  \n    Freitag, 13. M√§rz \n    3,90 \n  \n  \n    Montag, 16. M√§rz \n    NA \n  \n\n\n\n\n\nWie √§ndert der fehlende Wert die Berechnung der Summe?\nLesen Sie, was passiert, wenn der Datenvektor bei der Berechnung der Summe fehlende Werte enth√§lt. Rufen Sie dazu die Hilfe auf, i.e.¬†?sum.\nKorrigieren Sie die Berechnung der Summe entsprechend.\n\n\n\n1.4.7 Ihr erster Plot\nVor allem am Anfang kann die Lernkurve in R recht flach verlaufen. Daher sollten Sie nicht vergessen, warum Sie R lernen, n√§mlich um echte Datens√§tze zu analysieren.\nAuch wenn Sie den Code unten noch nicht verstehen, kopieren Sie ihn in einen neuen R-Chunk in Ihrem Notebook und lassen Sie ihn laufen.\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\ngapminder2007 <- gapminder %>% \n  filter(year == 2007)\n\nggplot(gapminder2007, aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  xlab('Bruttoinlandsprodukt pro Einwohner ($, inflationsbereinigt)') +\n  ylab('Lebenserwartung bei der Geburt (Jahre)') +\n  labs(title = 'Daten von Gapminder f√ºr das Jahr 2007')\n\n\nWelche Daten sind in diesem Datensatz enthalten? Nutzen Sie die Hilfe, i.e.¬†?gapminder.\nWas stellen die Farben in der Abbildung dar?\nWas wird durch die Symbolgr√∂√üe dargestellt?\nWie w√ºrden Sie den Zusammenhang zwischen den Variablen Bruttoinlandsprodukt pro Einwohner ($, inflationsbereinigt) und Lebenserwartung bei der Geburt (Jahre) beschreiben?"
  },
  {
    "objectID": "01-erste-schritte.html#ihre-arbeit-einreichen",
    "href": "01-erste-schritte.html#ihre-arbeit-einreichen",
    "title": "1¬† Erste Schritte in R",
    "section": "1.6 Ihre Arbeit einreichen",
    "text": "1.6 Ihre Arbeit einreichen\n\nSpeichern Sie Ihre .Rmd Datei ab.\nLaden Sie die Datei auf ILIAS in Ihrer √úbungsgruppe in der dazugeh√∂rigen √úbung hoch.\nNach der Abgabe erhalten Sie die Musterl√∂sung.\nVergleichen Sie Ihre L√∂sung selbstst√§ndig mit der Musterl√∂sung.\nStellen Sie entweder in Campuswire (im #class-chat) oder in der n√§chsten Sitzung Fragen, falls Sie bei den Aufgaben etwas nicht verstanden haben und die Musterl√∂sung es nicht aufkl√§ren konnte.\n\n\n\nBeachten Sie die Deadline f√ºr das Hochladen der Hausaufgaben!"
  },
  {
    "objectID": "01-erste-schritte.html#lesestoff-1",
    "href": "01-erste-schritte.html#lesestoff-1",
    "title": "1¬† Erste Schritte in R",
    "section": "1.7 Lesestoff",
    "text": "1.7 Lesestoff\nr4ds, Kapitel 4 (Wickham and Grolemund 2021)\n\n\n\n\nIhaka, Ross, and Robert Gentleman. 1996. ‚ÄúR: A Language for Data Analysis and Graphics.‚Äù Journal of Computational and Graphical Statistics 5 (3): 299‚Äì314. https://doi.org/10.1080/10618600.1996.10474713.\n\n\nIsmay, Chester, and Albert Y. Kim. 2021. ModernDive: Statistical Inference via Data Science. https://moderndive.com/.\n\n\nWickham, Hadley, and Garrett Grolemund. 2021. R for Data Science. https://r4ds.had.co.nz/."
  },
  {
    "objectID": "02-rmarkdown.html",
    "href": "02-rmarkdown.html",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "",
    "text": "Wichtigkeit der Reproduzierbarkeit erkl√§ren\nBegriff literate programming definieren\nAufbau einer RMarkdown-Datei erkl√§ren\nEinen einfachen ersten reproduzierbaren Bericht selbst schreiben"
  },
  {
    "objectID": "02-rmarkdown.html#warum-reproduzierbarkeit-in-der-forschung-wichtig-ist",
    "href": "02-rmarkdown.html#warum-reproduzierbarkeit-in-der-forschung-wichtig-ist",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.1 Warum Reproduzierbarkeit in der Forschung wichtig ist",
    "text": "2.1 Warum Reproduzierbarkeit in der Forschung wichtig ist\nAls Motivation f√ºr dieses Thema empfehle ich das Video von Prof.¬†Roger Peng der John Hopkins Bloogmerg School of Public Health."
  },
  {
    "objectID": "02-rmarkdown.html#literate-programming-idee-von-donald-knuth",
    "href": "02-rmarkdown.html#literate-programming-idee-von-donald-knuth",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.2 Literate Programming Idee von Donald Knuth",
    "text": "2.2 Literate Programming Idee von Donald Knuth\nDie Idee, dass man den Code und die dazugeh√∂rige Interpretation (Text, Bericht etc.) nicht voneinander trennen sollte, geht auf Knuth (1984) zur√ºck. Mit Literate Programming meinte Knuth, dass Programme auch nichts anderes wie literarische Werke sind. Er setzte den Fokus darauf, mit Programmen menschlichen Benutzern zu erkl√§ren, was man den Computer machen lassen m√∂chte. Also weg vom computer- hin zum mensch-zentrierten Zugang. So wird Programmieren und in unserem Fall die Datenanalyse verst√§ndlich und vor allem reproduzierbar.\nLeider ist es in unserer modernen Forschungslandschaft immer noch nicht Standard. Das Trennen von Analyseergebnissen und Berichten (Forschungsartikeln) sorgt f√ºr viele (unentdeckte und unn√∂tige) Fehler und Frust."
  },
  {
    "objectID": "02-rmarkdown.html#reproduzierbare-berichte-mit-r-markdown",
    "href": "02-rmarkdown.html#reproduzierbare-berichte-mit-r-markdown",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.3 Reproduzierbare Berichte mit R Markdown",
    "text": "2.3 Reproduzierbare Berichte mit R Markdown\nR hat sein eigenes System von reproduzierbaren Berichten, genannt R Markdown (Xie, Allaire, and Grolemund 2021). Es ist benutzerfreundlich und erm√∂glicht unterschiedliche Formate von Berichten, wie HTML-Dokumente, PDF-Dateien, Pr√§sentationsfolien usw.\nEs wird Sie vielleicht √ºberraschen, aber das Skript, das Sie gerade lesen, ist nichts anderes als ein ‚Äúliterarisch‚Äù programmiertes Buch in R Bookdown (Xie, Allaire, and Grolemund 2021), einem R-Paket speziell f√ºr lange R Markdown-Dokumente.\nWir werden vor allem mit R Notebooks arbeiten, die eine gute Interaktion zwischen dem geschriebenen Text und dem R-Code erm√∂glichen. Das Notebook kann sowohl in ein HTML-Dokument als auch in PDF oder Word als endg√ºltiges Dokument umgewandelt werden. Diesen Prozess nennt man knit."
  },
  {
    "objectID": "02-rmarkdown.html#ein-neues-r-notebook-erstellen",
    "href": "02-rmarkdown.html#ein-neues-r-notebook-erstellen",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.4 Ein neues R Notebook erstellen",
    "text": "2.4 Ein neues R Notebook erstellen\nUm ein neues R Notebook zu erstellen, klicken Sie das kleine gr√ºne Plus oben links und w√§hlen Sie R Notebook aus. Sie k√∂nnen es erst einmal bei untitled belassen (Figure¬†2.1).\n\n\n\nFigure¬†2.1: Neues R Notebook anlegen\n\n\nWenn Sie ein neues Notebook erstellen, enth√§lt das Template etwas Code. Lesen Sie sich das ruhig noch einmal durch, da es ein paar hilfreiche Tastenk√ºrzel und Tipps. Danach k√∂nnen Sie den Text unterhalb des Headers l√∂schen."
  },
  {
    "objectID": "02-rmarkdown.html#header",
    "href": "02-rmarkdown.html#header",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.5 Der Header eines Notebooks",
    "text": "2.5 Der Header eines Notebooks\nEin R Notebook (und jedes andere R Markdown Dokument) besteht aus einem Header (Kopf) und dem eigentlichen Text und Code. Der Header hat dabei ein bestimmtes Layout, auf das Sie unbedingt achten m√ºssen (Rechtschreibung!). Der Header ist immer zwischen drei Minuszeichen --- eingeschlossen. Bei komplizierteren Headern gibt es auch Einr√ºckungen (mit der Tab-Taste), die auch Bedeutung haben (s. weiterf√ºhrende Literatur). Wir bleiben bei einem einfachen Header ohne Einr√ºckungen (Abbildung Figure¬†2.2).\nUm einen neuen R-Chunk hinzuzuf√ºgen, klicken Sie auf das kleine gr√ºne C+ oben rechts oder verwenden Sie das Tastenk√ºrzel Str+Alt+i.\n\n\n\nFigure 2.2: Einen neuen R Chunk hinzuf√ºgen\n\n\nText kann einfach unterhalb des Headers und au√üerhalb der Chunks getippt werden. Die wichtigsten Layoutelemente f√ºr den Text finden Sie hier. R Markdown unterst√ºtzt mathematische Notation in Latex-Stil. Eine Einf√ºhrung in Latex w√ºrde an dieser Stelle aber zu weit f√ºhren.\nDas R Notebook hat den Vorteil, dass man √ºber den Button Preview oben in der Leiste sofort die Ergebnisse anzeigen lassen kann. Sie m√ºssen also nicht knitten. Falls Sie es doch m√∂chten, klicken Sie auf das kleine Dreieck neben dem Preview und suchen Sie sich ein Output-Format aus. Ein einmal ‚Äúgeknittetes‚Äù Notebook ist kein Notebook mehr (kein Preview). Damit es wieder zum Nobebook wird, m√ºssen Sie im Header output: html_notebbok einstellen (Abbildung (fig:rmarkdown-file?))."
  },
  {
    "objectID": "02-rmarkdown.html#wichtigste-regeln-f√ºr-reproduzierbarkeit",
    "href": "02-rmarkdown.html#wichtigste-regeln-f√ºr-reproduzierbarkeit",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.6 Wichtigste Regeln f√ºr Reproduzierbarkeit",
    "text": "2.6 Wichtigste Regeln f√ºr Reproduzierbarkeit\nEin weiteres Video von Prof.¬†Peng widmet sich den wichtigsten Regeln f√ºr Reproduzierbarkeit."
  },
  {
    "objectID": "02-rmarkdown.html#lesestoff",
    "href": "02-rmarkdown.html#lesestoff",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.7 Lesestoff",
    "text": "2.7 Lesestoff\nIntro zu Kapitel 2 (Basics), Kapitel 3.2.1 und 3.2.2 in Xie, Allaire, and Grolemund (2021)"
  },
  {
    "objectID": "02-rmarkdown.html#weiterf√ºhrende-literatur",
    "href": "02-rmarkdown.html#weiterf√ºhrende-literatur",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.8 Weiterf√ºhrende Literatur",
    "text": "2.8 Weiterf√ºhrende Literatur\nr4ds, Kapitel 27 (Wickham and Grolemund 2021)"
  },
  {
    "objectID": "02-rmarkdown.html#aufgaben",
    "href": "02-rmarkdown.html#aufgaben",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.9 Aufgaben",
    "text": "2.9 Aufgaben\n\n2.9.1 Erstes Notebook\n\nErstellen Sie ein R Notebook.\nF√ºgen Sie Layoutelemente hinzu:\n\n√úberschrift\nUnter√ºberschrift\nkursiver Text\nein Exponent: R2\nein Mathematikelement: \\(x^2\\)\neine Liste\n\n\nNutzen Sie die unter Section¬†2.5 verlinkte Liste der Layoutelemente.\n\n\n2.9.2 Erste Schritte als Notebook\n\nEditieren Sie das R Notebook der ersten Session.\nGliedern Sie Ihr Notebook mit passenden Layoutelementen.\nF√ºgen Sie mehr Erkl√§rungstext zu den einzelnen Abschnitten.\n\n\n\n\n\nKnuth, D. E. 1984. ‚ÄúLiterate Programming.‚Äù The Computer Journal 27 (2): 97‚Äì111. https://doi.org/10.1093/comjnl/27.2.97.\n\n\nWickham, Hadley, and Garrett Grolemund. 2021. R for Data Science. https://r4ds.had.co.nz/.\n\n\nXie, Yihui, J. J. Allaire, and Garrett Grolemund. 2021. R Markdown: The Definitive Guide. https://bookdown.org/yihui/rmarkdown/."
  },
  {
    "objectID": "01-erste-schritte.html#gemeinsame-aufgaben",
    "href": "01-erste-schritte.html#gemeinsame-aufgaben",
    "title": "1¬† Erste Schritte in R",
    "section": "1.4 Gemeinsame Aufgaben",
    "text": "1.4 Gemeinsame Aufgaben\n\nBitte speichern Sie Ihr Skript regelm√§√üig ab!\n\n\n1.4.1 Ars Haushaltsbuch\nDer angehende Datenanalyst Ar Stat m√∂chte dem Rat seiner Mutter folgen und ein Haushaltsbuch anlegen. Zuerst m√∂chte er sich einen √úberblick √ºber seine Ausgaben in der Uni-Mensa verschaffen und erstellt die folgende Tabelle:\n\n\n\nArs Mensaausgaben\n \n  \n    Wochentag \n    Ausgaben (‚Ç¨) \n  \n \n\n  \n    Montag \n    2,57 \n  \n  \n    Dienstag \n    2,90 \n  \n  \n    Mittwoch \n    2,73 \n  \n  \n    Donnerstag \n    3,23 \n  \n  \n    Freitag \n    3,90 \n  \n\n\n\n\n\nWie viel hat Ar insgesamt in der Woche ausgegeben?\nWie gro√ü ist die Differenz zwischen dem h√∂chsten und dem niedrigsten Betrag?\nWie viel h√§tte er insgesamt ausgegeben, wenn er jeden Tag so viel gezahlt h√§tte, wie am Dienstag. Wichtig: Verwenden Sie die [], um den Betrag von Dienstag auszuw√§hlen!\n\nLeider hat Ar sich beim √úbertragen der Daten vertippt. Er hat am Dienstag seine Freundin zum Essen eingeladen und 7,95 ‚Ç¨ statt 2,90 ‚Ç¨ ausgegeben.\n\nKorrigieren Sie Ars Fehler.\nWie ver√§ndern sich die Ergebnisse aus den Teilaufgaben 1 bis 3?\n\n\n\n1.4.2 Fehlende Werte\nR kodiert fehlende Werte mit NA. Ar Stat hat am Montag der darauffolgenden Woche in der Mensa gegessen, aber vergessen die Ausgaben zu notieren.\n\n\n\nArs Mensaausgaben, cont.\n \n  \n    Wochentag \n    Amount spent (‚Ç¨) \n  \n \n\n  \n    Montag, 9. M√§rz \n    2,57 \n  \n  \n    Dienstag, 10. M√§rz \n    2,90 \n  \n  \n    Mittwoch, 11. M√§rz \n    2,73 \n  \n  \n    Donnerstag, 12. M√§rz \n    3,23 \n  \n  \n    Freitag, 13. M√§rz \n    3,90 \n  \n  \n    Montag, 16. M√§rz \n    NA \n  \n\n\n\n\n\nWie √§ndert der fehlende Wert die Berechnung der Summe?\nLesen Sie, was passiert, wenn der Datenvektor bei der Berechnung der Summe fehlende Werte enth√§lt. Rufen Sie dazu die Hilfe auf, i.e.¬†?sum.\nKorrigieren Sie die Berechnung der Summe entsprechend."
  },
  {
    "objectID": "01-erste-schritte.html#hausaufgaben",
    "href": "01-erste-schritte.html#hausaufgaben",
    "title": "1¬† Erste Schritte in R",
    "section": "1.5 Hausaufgaben",
    "text": "1.5 Hausaufgaben\n\n1.5.1 R als Taschenrechner\nR ist ein gro√üer Taschenrechner mit vielen bereits definierten Funktionen. Es gelten die √ºblichen Rechenregeln wie z.B. Punkt-vor-Strich und die Klammern.\n\nSchreiben Sie den Code, der 2 und 10 addiert\n\nDas korrekte Multiplikationszeichen in R ist *.\n\nGeben Sie den folgenden Befehl korrekt in R ein: (2 + 10) \\(\\times\\) 27\n\nBei Dezimalzahlen wird der Dezimalpunkt und nicht das Komma verwendet. Das ist wichtig zu beachten, wenn Sie sp√§ter Daten in R einlesen m√∂chten.\n\nBerechnen Sie die Summe von 2,34 und 4,98.\n\n\n\n1.5.2 Zuweisungen\nIn R arbeitet man mit Objekten. Ein Objekt kann alles M√∂gliche sein: eine Variable, Daten, Vektoren etc. Wenn also das Ergebnis einer Berechnung oder ein Datenobjekt im R-Arbeitsbereich (workspace) zur Verf√ºgung stehen soll, muss daraus ein Objekt erstellt werden.\nObjekte erstellt man, indem man ihnen Namen gibt. Diesen Vorgang nennt man Zuweisung (assignment). Im Beispiel unten wird ein Objekt, in diesem Fall ein Skalar, namens x erzeugt, mit dem Wert 42. Um den Wert von x anzuzeigen, tippen Sie x ein.\n\nx <- 42\n\n# Zeige den Wert von x\nx\n\nZuweisungen k√∂nnen in R entweder mit dem = erfolgen oder mit <-. Beide Varianten sind gleichwertig. Dabei ist allerdings Pfeilrichtung entscheidend! x <- 42 bedeutet: Die rechte Seite (Zahl 42) wird dem Objekt x zugeordnet. Wenn man die Pfeilrichtung umdreht, macht die Zuweisung keinen Sinn und man erh√§lt eine Fehlermeldung.\n\n# Sinnvolle Zuweisung\nx <- 42\n# Gleichwertige sinnvolle Zuweisung\nx = 42\n# Sinnloser Ausdruck. Fehlermeldung!\nx -> 42\n\nError in 42 <- x: ung√ºltige (do_set) linke Seite in Zuweisung\n\n\nObjektnamen k√∂nnen (fast) frei gew√§hlt werden. Sie m√ºssen mit einem Buchstaben beginnen und d√ºrfen keine Sonderzeichen enthalten. Bei l√§ngeren Namen empfiehlt sich ein _. Streng verboten sind Namen von vordefinierten Funktionen!\n\nErstellen Sie ein Objekt namens mein_objekt und weisen Sie ihm das Ergebnis der Berechnung \\(23^{2}\\) zu. Eine Potenz berechnen Sie mit ^.\n\nEine Zuweisung kann auch kompliziertere Anweisungen enthalten. Hier erstellen wir z.B. einen Vektor mithilfe der Funktion c (concatenate) und weisen das Ergebnis dem Objekt my_a zu.\n\nmy_a <- c(32, 54, 1.2, 398)\n\n\n\n1.5.3 Funktionsaufruf\nIn R gibt es eine Vielzahl von vordefinierten Funktionen. Ein Funktionsaufruf hat immer die gleiche Form: mach_das(damit) oder mach_das(damit, und_mit_dieser_einstellung). Z.B. wird die Summe auf einem Objekt mein_objekt mit sum(mein_objekt) berechnet.\n\nErstellen Sie einen Vektor mit den Zahlen 32, 54, 1,2 und 398 und weisen Sie ihn der Variablen my_a zu.\nBerechnen Sie die summe von my_a.\n\nSie k√∂nnen im √úbrigen auch Vektoren sinnvoll addieren.\n\nErstellen Sie einen Vektor my_b mit der passenden L√§nge und addieren Sie ihn zum Vektor my_a. Die Addition erfolgt elementweise.\n\nH√§ufig wollen wir f√ºr unsere Daten den Mittelwert berechnen.\n\nBerechnen Sie den Mittelwert von my_a\nBerechnen Sie die Standardabweichung von my_a.\n\n\n\n1.5.4 Objekte ansprechen\nUm das ‚ÄúInnenleben‚Äù der Objekte in R anzusprechen, gibt es verschieden M√∂glichkeiten. In diesem Tutorial konzentrieren wir uns auf Vektoren. Um die einzelnen Komponenten im Vektor anzusprechen, benutzt man eckige Klammern [ ]. Um eine bestimmte Komponente zu adressieren (anzusprechen), schreibt man die Platznummer der Komponente in die Klammer. Wenn man im Vektor my_c, z.B. die dritte Komponente extrahieren m√∂chte, dann schreibt man my_c[3]\n\nmy_c <- c(2, 45.7, pi, sqrt(23), 2^6)\nmy_c[3]\n\nWir k√∂nnen auch Vektoren erstellen, bei denen einzelne Elemente benannt sind.\n\nbenannt <- c('Koeln' = 50667, 'Berlin' = 10965, \"Stuttgart\" = 70173)\n\nElemente in solchen Vektoren kann man mit Namen in eckigen Klammern ansprechen. Die Namen m√ºssen in Anf√ºhrungszeichen geschrieben werden. Es spielt keine Rolle, ob Sie einfache oder doppelte Anf√ºhrungszeichen benutzen.\n\nFragen Sie nach dem Element Koeln im Vektor benannt.\n\n\n\n1.5.5 Ihr erster Plot\nVor allem am Anfang kann die Lernkurve in R recht flach verlaufen. Daher sollten Sie nicht vergessen, warum Sie R lernen, n√§mlich um echte Datens√§tze zu analysieren.\nAuch wenn Sie den Code unten noch nicht verstehen, kopieren Sie ihn in einen neuen R-Chunk in Ihrem Notebook und lassen Sie ihn laufen.\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\ngapminder2007 <- gapminder %>% \n  filter(year == 2007)\n\nggplot(gapminder2007, aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  labs(x = 'Bruttoinlandsprodukt pro Einwohner ($, inflationsbereinigt)', \n       y = 'Lebenserwartung bei der Geburt (Jahre)',\n       title = 'Daten von Gapminder f√ºr das Jahr 2007',\n       caption = 'http://www.gapminder.org/data/')\n\n\nWelche Daten sind in diesem Datensatz enthalten? Nutzen Sie die Hilfe, i.e.¬†?gapminder.\nWas stellen die Farben in der Abbildung dar?\nWas wird durch die Symbolgr√∂√üe dargestellt?\nWie w√ºrden Sie den Zusammenhang zwischen den Variablen Bruttoinlandsprodukt pro Einwohner ($, inflationsbereinigt) und Lebenserwartung bei der Geburt (Jahre) beschreiben?"
  },
  {
    "objectID": "02-rmarkdown.html#sec-header",
    "href": "02-rmarkdown.html#sec-header",
    "title": "2¬† R Markdown f√ºr reproduzierbare Forschung",
    "section": "2.5 Der Header eines Notebooks",
    "text": "2.5 Der Header eines Notebooks\nEin R Notebook (und jedes andere R Markdown Dokument) besteht aus einem Header (Kopf) und dem eigentlichen Text und Code. Der Header hat dabei ein bestimmtes Layout, auf das Sie unbedingt achten m√ºssen (Rechtschreibung!). Der Header ist immer zwischen drei Minuszeichen --- eingeschlossen. Bei komplizierteren Headern gibt es auch Einr√ºckungen (mit der Tab-Taste), die auch Bedeutung haben (s. weiterf√ºhrende Literatur). Wir bleiben bei einem einfachen Header ohne Einr√ºckungen (Figure¬†2.2).\nUm einen neuen R-Chunk hinzuzuf√ºgen, klicken Sie auf das kleine gr√ºne C+ oben rechts oder verwenden Sie das Tastenk√ºrzel Str+Alt+i.\n\n\n\nFigure¬†2.2: Einen neuen R Chunk hinzuf√ºgen\n\n\nText kann einfach unterhalb des Headers und au√üerhalb der Chunks getippt werden. Die wichtigsten Layoutelemente f√ºr den Text finden Sie hier. R Markdown unterst√ºtzt mathematische Notation in Latex-Stil. Eine Einf√ºhrung in Latex w√ºrde an dieser Stelle aber zu weit f√ºhren.\nDas R Notebook hat den Vorteil, dass man √ºber den Button Preview oben in der Leiste sofort die Ergebnisse anzeigen lassen kann. Sie m√ºssen also nicht knitten. Falls Sie es doch m√∂chten, klicken Sie auf das kleine Dreieck neben dem Preview und suchen Sie sich ein Output-Format aus. Ein einmal ‚Äúgeknittetes‚Äù Notebook ist kein Notebook mehr (kein Preview). Damit es wieder zum Nobebook wird, m√ºssen Sie im Header output: html_notebbok einstellen (Figure¬†2.2)."
  },
  {
    "objectID": "20-aufgabensammlung.html",
    "href": "20-aufgabensammlung.html",
    "title": "Appendix A ‚Äî Aufgabensammlung",
    "section": "",
    "text": "In einer Studie wurden 1100 Spitzschwanzammer (Ammodramus caudacutus) vermessen. Wir nutzen einen Teil des Datensatzes (Zuur, Ieno, and Meesters 2009). Die gemessenen Variablen sind Fluegel, Fuss (Tarsus), Kopf, Gewicht. Leider git die Datenquelle die Messeinheiten nicht an. Die Daten sind wie folgt:\n\n\n\n\n\n\n\n \n  \n    Fluegel \n    Fuss \n    Kopf \n    Gewicht \n  \n \n\n  \n    59.0 \n    22.3 \n    31.2 \n    9.5 \n  \n  \n    55.0 \n    19.7 \n    30.4 \n    13.8 \n  \n  \n    53.5 \n    20.8 \n    30.6 \n    14.8 \n  \n  \n    55.0 \n    20.3 \n    30.3 \n    15.2 \n  \n  \n    52.5 \n    20.8 \n    30.3 \n    15.5 \n  \n  \n    57.5 \n    21.5 \n    30.8 \n    15.6 \n  \n  \n    53.0 \n    20.6 \n    32.5 \n    15.6 \n  \n  \n    55.0 \n    21.5 \n    NA \n    15.7 \n  \n\n\n\n\n\n\nErstellen Sie jede Variable einzeln mithilfe der Funktion c().\nWie viele V√∂gel sind in der Tabelle zu finden. Nutzen Sie dazu die Funktion length(). Sehen Sie in der Hilfe nach, wie man diese benutzt.\nF√ºhren Sie alle Variablen zu einem einzelnen Datenobjekt, einem tibble zusammen mithilfe der Funktion tibble() aus dem R-Paket tibble."
  },
  {
    "objectID": "03-ggplot.html",
    "href": "03-ggplot.html",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "",
    "text": "Aufbau des Aufrufs der Funktion ggplot() kennen\nf√ºnf wichtigste Grafiktypen kennen und einsetzten"
  },
  {
    "objectID": "03-ggplot.html#aufbau-eines-darstellungsbefehls",
    "href": "03-ggplot.html#aufbau-eines-darstellungsbefehls",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.1 Aufbau eines Darstellungsbefehls",
    "text": "3.1 Aufbau eines Darstellungsbefehls\nDas Paket ggplot2 ist ein sehr m√§chtiges Visualisierungswerkzeug. Der Name steht f√ºr ‚Äúthe grammar of graphics‚Äù. Das bedeutet, dass man mithilfe von verschiedenen Funktion in ggplot2 seine Grafik Schritt f√ºr Schritt aufbaut, wie einen (grammatikalisch korrekten) Satz. In aller K√ºrze bedeutet das:\n\nEine statistische Grafik ist eine Zuordnung (mapping) von Variablen in einem Datensatz (data) zu (√§sthetischen) Attributen (aes) von geometrischen Objekten (geom).\n\nWir m√ºssen also f√ºr die Darstellung von Daten R Folgendes mitteilen:\n\ndata: der Datensatz, der die Variablen enth√§lt, die wir darstellen m√∂chten.\naes: (√§sthetische) Attribute f√ºr die geometrischen Objekte, die dargestellt werden sollen. Diese Attribute sind, z.B. die x und y Koordinaten, Farbe, Form und Gr√∂√üe der geometrischen Objekte\ngeom: geometrische Objekte, die dargestellt werden sollen, z.B. Punkte, Linien, Boxen, Balken/S√§ulen etc.\n\nWir laden zun√§chst die n√∂tigen Bibliotheken.\n\nlibrary(ggplot2)\nlibrary(gapminder)\n\nAnschlie√üend filtern wir den Datensatz gapminder, um nur die Daten aus dem Jahr 2007 zu behalten. Der Code filter(year == 2007) bedeutet, dass wir nur die Zeilen aus dem Datensatz behalten wollen, in denen in der Variable year 2007 steht.\n\ngapminder2007 <- gapminder %>% \n  filter(year == 2007)\n\nWir √ºberzeugen uns davon, dass es geklappt hat üòÑ. Bl√§ttern Sie durch den Datensatz und √ºberpr√ºfen Sie die Werte in der Variablen year.\n\ngapminder2007"
  },
  {
    "objectID": "03-ggplot.html#punktdiagramm",
    "href": "03-ggplot.html#punktdiagramm",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.2 Punktdiagramm",
    "text": "3.2 Punktdiagramm\nEin typischer Befehl zur Visualisierung w√ºrde also so aussehen:\n\nggplot(data = gapminder2007, mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +\n  geom_point()\n\n{width== ‚Äú90%‚Äù}\n\n\nIn Worten k√∂nnte man es vielleicht wie folgt umschreiben:\n\nNimm den Datensatz (data) gapminder und\nordne folgende Attribute zu:\n\nauf die x-Achse die Variable gdpPercap\nauf die y-Achse die Variable lifeExp\nf√§rbe ein mithilfe der Variablen continent\nbestimme die Gr√∂√üe der Symbole mithilfe der Variablen pop\n\nStelle das Ganze als geometrisches Objekte Punkte dar (geom_point())\n\nSie sehen, dass diese Zuordnungen klar nach einer Legende verlangen, die dann auch automatisch, sowohl f√ºr die Farbe als auch f√ºr die Gr√∂√üe der Symbole, erstellt wird.\nDie Anweisungen zur Visualisierung in ggplot2 werden mit einem + verbunden. Man kann (und in diesem Fall soll) weitere Anweisungen geben. Z.B. sind die Beschriftungen der beiden Achsen so nichtssagend und m√ºssen verbessert werden. Wir h√§ngen mit einem +-Zeichen weitere Befehle hinzu:\n\nggplot(data = gapminder2007, mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +\n  geom_point() + \n  labs(x = 'Bruttoinlandsprodukt pro Kopf (US$)', y = 'Lebenserwartung (Jahre)',\n       color = 'Kontinent', size = 'Bev√∂lkerung')\n\n{width== ‚Äú90%‚Äù}"
  },
  {
    "objectID": "03-ggplot.html#weitere-geoms",
    "href": "03-ggplot.html#weitere-geoms",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.3 Weitere geoms",
    "text": "3.3 Weitere geoms\nDas geom_point() produziert ein Streudiagramm auch XY-Diagramm (scatter plot). Weiter wichtige Grafiktypen sind\n\ngeom_line(): Linien\ngeom_bar(): Balken"
  },
  {
    "objectID": "03-ggplot.html#scatter",
    "href": "03-ggplot.html#scatter",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.2 Streudiagramm",
    "text": "3.2 Streudiagramm\nEin typischer Befehl zur Visualisierung eines Streudiagramms w√ºrde so aussehen:\n\nggplot(data = gapminder2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +\n  geom_point()\n\n\n\n\nIn Worten k√∂nnte man es vielleicht wie folgt umschreiben:\n\nNimm den Datensatz (data) gapminder und\nordne folgende Attribute zu:\n\nauf die x-Achse die Variable gdpPercap (Bruttoinlandsprodukt)\nauf die y-Achse die Variable lifeExp (Lebenserwartung)\nf√§rbe ein mithilfe der Variablen continent (Kontinent)\n\nStelle das Ganze als geometrisches Objekte Punkte dar (geom_point())\n\nSie sehen, dass diese Zuordnungen klar nach einer Legende verlangen, die dann auch automatisch, sowohl f√ºr die Farbe continent als auch f√ºr die Gr√∂√üe der Symbole pop, erstellt wird.\nDie Anweisungen zur Visualisierung in ggplot2 werden mit einem + verbunden. Man kann (und in diesem Fall soll) weitere Anweisungen geben. Z. B. sind die Beschriftungen der beiden Achsen so nichts sagend und m√ºssen verbessert werden. Wir h√§ngen mit einem +-Zeichen weitere Befehle hinzu:\n\nggplot(data = gapminder2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() + \n  labs(x = 'Bruttoinlandsprodukt pro Einwohner (US$, inflationsbereinigt)',\n       y = 'Lebenserwartung bei der Geburt (Jahre)',\n       color = 'Kontinent',\n       title = 'Daten von Gapminder f√ºr das Jahr 2007',\n       caption = 'http://www.gapminder.org/data/')"
  },
  {
    "objectID": "03-ggplot.html#histogramm",
    "href": "03-ggplot.html#histogramm",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.5 Histogramm",
    "text": "3.5 Histogramm\nWie ist das GDP im Jahre 2007 in Afrika und Europa verteilt? Dazu nutzen wir das Histogramm und filtern die Daten vorher entsprechend. Als √Ñsthetik eignet sich hier fill besser als color.\n\nafrica_europe <- gapminder2007 %>% \n  filter(continent %in% c('Africa', 'Europe'))\n\nggplot(africa_europe, mapping = aes(x = gdpPercap, fill = continent)) +\n  geom_histogram(bins = 20)"
  },
  {
    "objectID": "03-ggplot.html#boxplot",
    "href": "03-ggplot.html#boxplot",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.6 Boxplot",
    "text": "3.6 Boxplot\nWie ist das GDP im Jahre 2007 auf verschiedenen Kontinenten verteilt? Ein Histogramm mit allen Kontinenten w√ºrde schnell sehr un√ºbersichtlich werden. Das geht mit einem Boxplot besser.\n\nggplot(gapminder2007, mapping = aes(x = continent, y = gdpPercap)) +\n  geom_boxplot()"
  },
  {
    "objectID": "03-ggplot.html#s√§ulendiagramm",
    "href": "03-ggplot.html#s√§ulendiagramm",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.5 S√§ulendiagramm",
    "text": "3.5 S√§ulendiagramm\nWie viele Eintr√§ge gibt es pro Kontinent? Das S√§ulendiagramm z√§hlt f√ºr uns die Eintr√§ge im Datensatz zusammen. Es stellt also dieselben Daten dar, die eine H√§ufigkeitstabelle enthalten w√ºrde.\n\nggplot(data = gapminder, \n       mapping = aes(x = continent)) +\n  geom_bar()"
  },
  {
    "objectID": "03-ggplot.html#lesestoff",
    "href": "03-ggplot.html#lesestoff",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.6 Lesestoff",
    "text": "3.6 Lesestoff\nKapitel 2.1 in Ismay and Kim (2021)"
  },
  {
    "objectID": "03-ggplot.html#aufgaben",
    "href": "03-ggplot.html#aufgaben",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.7 Aufgaben",
    "text": "3.7 Aufgaben\n\n3.7.1 Darstellung von gro√üen Zahlen\nWir ver√§ndern die Grafik aus Section¬†3.2 so, dass die Symbole nach der Gr√∂√üe der Einwohnerzahl skaliert werden. Dazu benutzen wir ein neues Argument in der Funktion aes(size = pop):\n\nggplot(data = gapminder2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +\n  geom_point() + \n  labs(x = 'Bruttoinlandsprodukt pro Einwohner (US$, inflationsbereinigt)',\n       y = 'Lebenserwartung bei der Geburt (Jahre)',\n       color = 'Kontinent',\n       title = 'Daten von Gapminder f√ºr das Jahr 2007',\n       caption = 'http://www.gapminder.org/data/')\n\n\n\n\nDie Einwohnerzahlen sind sehr gro√ü. Daher stellt R sie in der sogen. wissenschaftlichen Notation dar. Dabei steht z. B. e+08 f√ºr \\(10^8\\). Das hei√üt 2.5e+08 sind 250000000 Einwohner.\nBeschriften Sie die Legende f√ºr die Gr√∂√üe der Symbole richtig, indem Sie size = 'Einwohnerzahl' in der Funktion labs() hinzuf√ºgen.\n\n\n3.7.2 Grafiken richtig beschriften\nBis auf die Grafik in Section¬†3.4 fehlen bei den Grafiken oben ordentliche Achsenbeschriftungen und Titel f√ºr die Legenden. Erg√§nzen Sie den Code entsprechend."
  },
  {
    "objectID": "03-ggplot.html#ihre-arbeit-einreichen",
    "href": "03-ggplot.html#ihre-arbeit-einreichen",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.8 Ihre Arbeit einreichen",
    "text": "3.8 Ihre Arbeit einreichen\n\nSpeichern Sie Ihr Notebook ab.\nLaden Sie Ihre .Rmd Datei in ILIAS hoch. Beachten Sie die Frist!\nSie erhalten die Musterl√∂sung nach dem Hochladen.\n\n\n\n\n\nIsmay, Chester, and Albert Y. Kim. 2021. ModernDive: Statistical Inference via Data Science. https://moderndive.com/."
  },
  {
    "objectID": "03-ggplot.html#streudiagramm",
    "href": "03-ggplot.html#streudiagramm",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.2 Streudiagramm",
    "text": "3.2 Streudiagramm\nEin typischer Befehl zur Visualisierung eines Streudiagramms w√ºrde so aussehen:\n\nggplot(data = gapminder2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +\n  geom_point()\n\n\n\n\nIn Worten k√∂nnte man es vielleicht wie folgt umschreiben:\n\nNimm den Datensatz (data) gapminder und\nordne folgende Attribute zu:\n\nauf die x-Achse die Variable gdpPercap (Bruttoinlandsprodukt)\nauf die y-Achse die Variable lifeExp (Lebenserwartung)\nf√§rbe ein mithilfe der Variablen continent (Kontinent)\nbestimme die Gr√∂√üe der Symbole mithilfe der Variablen pop (Einwohnerzahl)\n\nStelle das Ganze als geometrisches Objekte Punkte dar (geom_point())\n\nSie sehen, dass diese Zuordnungen klar nach einer Legende verlangen, die dann auch automatisch, sowohl f√ºr die Farbe continent als auch f√ºr die Gr√∂√üe der Symbole pop, erstellt wird.\nDie Anweisungen zur Visualisierung in ggplot2 werden mit einem + verbunden. Man kann (und in diesem Fall soll) weitere Anweisungen geben. Z. B. sind die Beschriftungen der beiden Achsen so nichts sagend und m√ºssen verbessert werden. Wir h√§ngen mit einem +-Zeichen weitere Befehle hinzu:\n\nggplot(data = gapminder2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +\n  geom_point() + \n  labs(x = 'Bruttoinlandsprodukt pro Einwohner (US$, inflationsbereinigt)',\n       y = 'Lebenserwartung bei der Geburt (Jahre)',\n       color = 'Kontinent',\n       size = 'Einwohnerzahl',\n       title = 'Daten von Gapminder f√ºr das Jahr 2007',\n       caption = 'http://www.gapminder.org/data/')"
  },
  {
    "objectID": "03-ggplot.html#line",
    "href": "03-ggplot.html#line",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.4 Liniendiagramm",
    "text": "3.4 Liniendiagramm\nEs ergibt wenig Sinn, die obere Grafik mit Linien darzustellen. Allerdings eignen sich Linien ausgezeichnet, um einen zeitlichen Verlauf zu visualisieren. Daher filtern wir aus dem Datensatz gapminder die Zeitreihen f√ºr Frankreich und Deutschland heraus. Weil wir jetzt zwei L√§nder haben m√∂chten, muss beim Filtern ein Vektor mit L√§ndernamen angegeben werden und statt == der Operator %in%. Wir werden sp√§ter noch ausf√ºhrlich auf diese Operatoren zur√ºckkommen.\n\nfrance_germany <- gapminder %>% \n  filter(country %in% c('France', 'Germany'))\n\n\nggplot(data = france_germany, \n       mapping = aes(x = year, y = gdpPercap, color = country)) +\n  geom_line()"
  },
  {
    "objectID": "03-ggplot.html#sec-scatter",
    "href": "03-ggplot.html#sec-scatter",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.2 Streudiagramm",
    "text": "3.2 Streudiagramm\nEin typischer Befehl zur Visualisierung eines Streudiagramms w√ºrde so aussehen:\n\nggplot(data = gapminder2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point()\n\n\n\n\nIn Worten k√∂nnte man es vielleicht wie folgt umschreiben:\n\nNimm den Datensatz gapminder2007 (data = gapminder2007) und\nordne folgende Attribute zu:\n\nauf die x-Achse die Variable gdpPercap (x = gdpPercap) (Bruttoinlandsprodukt)\nauf die y-Achse die Variable lifeExp (y = lifeExp) (Lebenserwartung)\nf√§rbe ein mithilfe der Variablen continent (color = continent).\n\nStelle das Ganze als geometrisches Objekt Punkte dar (geom_point())\n\nSie sehen, dass diese Zuordnungen klar nach einer Legende verlangen, die dann auch automatisch erstellt wird. Merke: color innerhalb der Funktion aes() erstellt die Legende automatisch.\nDie Anweisungen zur Visualisierung in ggplot2 werden mit einem + verbunden. Man kann (und in diesem Fall soll) weitere Anweisungen geben. Z. B. sind die Beschriftungen der beiden Achsen so nichtssagend und m√ºssen verbessert werden. Wir h√§ngen mit einem +-Zeichen weitere Befehle hinzu:\n\nggplot(data = gapminder2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() + \n  labs(x = 'Bruttoinlandsprodukt pro Einwohner (US$, inflationsbereinigt)',\n       y = 'Lebenserwartung bei der Geburt (Jahre)',\n       color = 'Kontinent',\n       title = 'Daten von Gapminder f√ºr das Jahr 2007',\n       caption = 'http://www.gapminder.org/data/')"
  },
  {
    "objectID": "03-ggplot.html#sec-line",
    "href": "03-ggplot.html#sec-line",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.4 Liniendiagramm",
    "text": "3.4 Liniendiagramm\nEs ergibt wenig Sinn, die obere Grafik mit Linien darzustellen. Allerdings eignen sich Linien ausgezeichnet, um einen zeitlichen Verlauf zu visualisieren. Daher filtern wir aus dem Datensatz gapminder die Zeitreihen f√ºr Frankreich und Deutschland heraus. Weil wir jetzt zwei L√§nder haben m√∂chten, muss beim Filtern ein Vektor mit L√§ndernamen angegeben werden und statt == der Operator %in%. Wir werden sp√§ter noch ausf√ºhrlich auf diese Operatoren zur√ºckkommen.\n\nfrance_germany <- gapminder %>% \n  filter(country %in% c('France', 'Germany'))\n\n\nggplot(data = france_germany, \n       mapping = aes(x = year, y = gdpPercap, color = country)) +\n  geom_line()"
  },
  {
    "objectID": "20-aufgabensammlung.html#einf√ºhrung-in-die-darstellung-von-daten",
    "href": "20-aufgabensammlung.html#einf√ºhrung-in-die-darstellung-von-daten",
    "title": "Appendix A ‚Äî Aufgabensammlung",
    "section": "A.2 Einf√ºhrung in die Darstellung von Daten",
    "text": "A.2 Einf√ºhrung in die Darstellung von Daten\n\nA.2.1 Pinguine\n\nLaden Sie die Bibliotheken tidyverse und palmerpenguins mithilfe der Funktion library().\nLaden Sie den Datensatz penguins mithilfe der Funktion data().\nSehen Sie sich den Datensatz an.\nPlotten Sie ein Streudiagramm der Variablen Flossenl√§nge flipper_length_mm auf der \\(x\\)-Achse und der Variablen K√∂rpergewicht body_mass_g auf der \\(y\\)-Achse.\nBeschriften Sie die Grafik sinnvoll.\nF√§rben Sie die Punkte je nach Art unterschiedlich ein mithilfe der Variablen species.\n\nSie sollten die gleiche (bis auf die Farbauswahl) Grafik erhalten, wie in der Vorlesung ü§ì."
  },
  {
    "objectID": "03-ggplot.html#balkendiagramm",
    "href": "03-ggplot.html#balkendiagramm",
    "title": "3¬† Einf√ºhrung in die Darstellung von Daten",
    "section": "3.5 Balkendiagramm",
    "text": "3.5 Balkendiagramm\nWie viele L√§nder gibt es pro Kontinent im Jahr 2007? Das Balkendiagramm z√§hlt f√ºr uns die Eintr√§ge im Datensatz zusammen. Es stellt also dieselben Daten dar, die eine H√§ufigkeitstabelle enthalten w√ºrde.\n\nggplot(data = gapminder2007, \n       mapping = aes(x = continent)) +\n  geom_bar()"
  },
  {
    "objectID": "04-einlesen.html",
    "href": "04-einlesen.html",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "",
    "text": "Daten aus Textdateien in R einlesen\nDie $-Notation\nAnsprechen eines Eintrags im tibble\nDaten als Textdateien aus R speichern"
  },
  {
    "objectID": "04-einlesen.html#lesestoff",
    "href": "04-einlesen.html#lesestoff",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.6 Lesestoff",
    "text": "4.6 Lesestoff\nKapitel 4.1 in Ismay and Kim (2021)"
  },
  {
    "objectID": "04-einlesen.html#aufgaben",
    "href": "04-einlesen.html#aufgaben",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.7 Aufgaben",
    "text": "4.7 Aufgaben"
  },
  {
    "objectID": "04-einlesen.html#ihre-arbeit-einreichen",
    "href": "04-einlesen.html#ihre-arbeit-einreichen",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.9 Ihre Arbeit einreichen",
    "text": "4.9 Ihre Arbeit einreichen\n\nSpeichern Sie Ihr Notebook ab.\nLaden Sie Ihre .Rmd Datei in ILIAS hoch. Beachten Sie die Frist!\nSie erhalten die Musterl√∂sung nach dem Hochladen.\n\n\n\n\n\nIsmay, Chester, and Albert Y. Kim. 2021. ModernDive: Statistical Inference via Data Science. https://moderndive.com/."
  },
  {
    "objectID": "05-explorative-kategorial.html",
    "href": "05-explorative-kategorial.html",
    "title": "5¬† Exploration von kategorialen Daten",
    "section": "",
    "text": "Den Pipe-Operator %>%nutzen\nKategoriale Variablen in Faktor umwandeln\nKategoriale Variablen darstellen\nNeue Variablen mit mutate() erstellen\nH√§ufigkeits- und Kontingenztabellen erstellen"
  },
  {
    "objectID": "05-explorative-kategorial.html#lesestoff",
    "href": "05-explorative-kategorial.html#lesestoff",
    "title": "5¬† Exploration von kategorialen Daten",
    "section": "5.2 Lesestoff",
    "text": "5.2 Lesestoff\nKapitel 2.1 in Ismay and Kim (2021)"
  },
  {
    "objectID": "05-explorative-kategorial.html#aufgaben",
    "href": "05-explorative-kategorial.html#aufgaben",
    "title": "5¬† Exploration von kategorialen Daten",
    "section": "5.3 Aufgaben",
    "text": "5.3 Aufgaben\n\n5.3.1 Grafik beschriften\nBeschriften Sie die finale Grafik aus Section¬†5.1.2 so, dass sie wie dort anfangs dargestellt aussieht.\n\n\n5.3.2 Aufgaben der Funktion theme()\n\nLesen Sie nach, was die Aufgabe der Funktion theme() ist. Fassen Sie den Abschnitt Description kurz mit Ihren eigenen Worten zusammen.\nIch habe in der Vorlesung theme_classic() benutzt. √Ñndern Sie die finale Grafik in Section¬†5.1.2 so, dass auch dort dieses theme benutzt wird.\nFinden Sie heraus, was hjust und vjust tun. Probieren Sie die Werte 0, 0.5 und 1 aus. Wie √§ndert sich die Position der L√§ndernamen?\n\n\n\n5.3.3 Tutorium\nBearbeiten Sie das Tutorium ‚ÄúEinf√ºhrung in Daten: 1 - Die Sprache der Daten‚Äù. Sie k√∂nnen entweder die deutsche √úbersetzung oder das englische Original bearbeiten. Das Tutorium muss nicht hochgeladen werden."
  },
  {
    "objectID": "05-explorative-kategorial.html#ihre-arbeit-einreichen",
    "href": "05-explorative-kategorial.html#ihre-arbeit-einreichen",
    "title": "5¬† Exploration von kategorialen Daten",
    "section": "5.4 Ihre Arbeit einreichen",
    "text": "5.4 Ihre Arbeit einreichen\n\nSpeichern Sie Ihr Notebook ab.\nLaden Sie Ihre .Rmd Datei in ILIAS hoch. Beachten Sie die Frist!\nSie erhalten die Musterl√∂sung nach dem Hochladen."
  },
  {
    "objectID": "04-einlesen.html#daten-aus-textdateien-in-r-einlesen",
    "href": "04-einlesen.html#daten-aus-textdateien-in-r-einlesen",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.1 Daten aus Textdateien in R einlesen",
    "text": "4.1 Daten aus Textdateien in R einlesen\nUm Daten aus Textdateien (z.B. aus .csv, .txt, .dat) in R zu importieren (i.e.¬†einzulesen) werden wir die Bibliothek readr aus tidyverse benutzen. Wir laden erst einmal tidyverse.\n\nlibrary(tidyverse)\n\nWir gehen davon aus, dass die Daten im Ordner Daten gespeichert sind. Falls Ihre Daten an einem anderen Ort abgelegt sind, m√ºssen Sie den Pfad beim Einlesen entsprechend anpassen.\nUm die Daten zu laden, gibt es in der Bibliothek readr verschiedene Funktionen, die alle mit read_ beginnen. Die allgemeinste davon ist read_delim. Darin kann man explizit einstellen, mit welchem Zeichen (z. B. Komma, Strichpunkt etc.) die einzelnen Spalten in der zu importierenden Datei getrennt sind. In der Datei, die wir einlesen, ist das Trennungszeichen ;. Das m√ºssen Sie aber bei jeder Datei, die Sie einlesen, nachsehen.\n\ncar_numbers <- read_delim(file = 'Daten/autos_2022-11-06.csv', delim = ';')\n\nRows: 76 Columns: 4\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \";\"\nchr  (2): geo, unit\ndbl  (1): values\ndate (1): time\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nEin kurzer Blick auf den Datensatz, den Sie aus der ersten Sitzung der Vorlesung erkennen sollten üòÑ. Es sind die Daten zur Mobilit√§t in Europa aus eurostat, heruntergeladen am 06.11.2022 und vorgefiltert. Die Daten beinhalten die Anzhal der ‚ÄúPersonenkraftwagen je 1 000 Einwohner‚Äù, online Datencode: ROAD_EQS_CARHAB.\n\ncar_numbers\n\n\n\n  \n\n\n\nDas Ergebnis des Einlesens mit read_ Funktionen ist immer ein tibble."
  },
  {
    "objectID": "04-einlesen.html#einzlene-variablen-ansprechen",
    "href": "04-einlesen.html#einzlene-variablen-ansprechen",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.2 Einzlene Variablen ansprechen",
    "text": "4.2 Einzlene Variablen ansprechen\nJede Variable hat einen Namen. Man kann diesen Nutzen, um die Variable anzusprechen. Z. B. k√∂nnten wir die Variable geo so ansprechen:\n\ncars$geo\n\n [1] \"Albania\"         \"Albania\"         \"Austria\"         \"Austria\"        \n [5] \"Belgium\"         \"Belgium\"         \"Bulgaria\"        \"Bulgaria\"       \n [9] \"Croatia\"         \"Croatia\"         \"Cyprus\"          \"Cyprus\"         \n[13] \"Czechia\"         \"Czechia\"         \"Denmark\"         \"Denmark\"        \n[17] \"Estonia\"         \"Estonia\"         \"Finland\"         \"Finland\"        \n[21] \"France\"          \"France\"          \"Germany\"         \"Germany\"        \n[25] \"Greece\"          \"Greece\"          \"Hungary\"         \"Hungary\"        \n[29] \"Iceland\"         \"Iceland\"         \"Ireland\"         \"Ireland\"        \n[33] \"Italy\"           \"Italy\"           \"Kosovo\"          \"Kosovo\"         \n[37] \"Latvia\"          \"Latvia\"          \"Liechtenstein\"   \"Liechtenstein\"  \n[41] \"Lithuania\"       \"Lithuania\"       \"Luxembourg\"      \"Luxembourg\"     \n[45] \"Malta\"           \"Malta\"           \"Montenegro\"      \"Montenegro\"     \n[49] \"Netherlands\"     \"Netherlands\"     \"North Macedonia\" \"North Macedonia\"\n[53] \"Norway\"          \"Norway\"          \"Poland\"          \"Poland\"         \n[57] \"Portugal\"        \"Portugal\"        \"Romania\"         \"Romania\"        \n[61] \"Serbia\"          \"Serbia\"          \"Slovakia\"        \"Slovakia\"       \n[65] \"Slovenia\"        \"Slovenia\"        \"Spain\"           \"Spain\"          \n[69] \"Sweden\"          \"Sweden\"          \"Switzerland\"     \"Switzerland\"    \n[73] \"T√ºrkiye\"         \"T√ºrkiye\"         \"United Kingdom\"  \"United Kingdom\" \n\n\nSie sehen, dass die Darstellung jetzt anders aussieht, weil eine einzelne Variable ein Vektor ist und kein tibble. Vektoren werden (durchnummeriert) ausgegeben und wir sehen alle 76 Eintr√§ge (L√§nder) nacheinander in der Reihenfolge ihres Erscheinens in der Variablen geo."
  },
  {
    "objectID": "04-einlesen.html#ansprechen-mehrere-spalten-in-einem-tibble",
    "href": "04-einlesen.html#ansprechen-mehrere-spalten-in-einem-tibble",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.3 Ansprechen mehrere Spalten in einem tibble",
    "text": "4.3 Ansprechen mehrere Spalten in einem tibble\nEin tibble ist ein zwei-dimensionales Objekt: Es hat Zeilen (erste Dimension) und Spalten (zweite Dimension). Um so ein Objekt richtig anzusprechen, erweitern wir unsere Notation mit den eckigen Klammern. Jetzt brauchen wir n√§mlich zwei Indizes: einen Index f√ºr die Zeile und einen Index f√ºr die Spalte eines Eintrags. Wenn wir z. B. den dritten Eintrag in der ersten Spalte (Variable geo) sehen wollen, schreiben wir:\n\ncar_numbers[3, 1]\n\n\n\n  \n\n\n\nEs handelt sich um √ñsterreich. Wir k√∂nnen auch ganze Spalten (Variablen) ansprechen. Daf√ºr wird der erste Index (f√ºr Zeilen) weggelassen. Nichts (oder ein Leerzeichen) signalisieren R, dass alle Eintr√§ge gemeint sind. So k√∂nnen wir die erste Spalte wie folgt ansprechen:\n\ncar_numbers[, 1]\n\n\n\n  \n\n\n\nBeim Ansprechen ganzer Zeilen ist es √§hnlich. Wir lassen den Index f√ºr die Spalte weg. Um die erste Zeile anzusprechen, schreiben wir:\n\ncar_numbers[1,]\n\n\n\n  \n\n\n\nSie sollten einen wichtigen Unterschied zwischen der $-Notation und dem Ansprechen in eckigen Klammern bemerken: Die $-Notation gibt einen Vektor zur√ºck. Wenn Sie ein tibble mit eckigen Klammern ansprechen, ist die Antwort ein tibble."
  },
  {
    "objectID": "04-einlesen.html#ein-tibble-erstellen",
    "href": "04-einlesen.html#ein-tibble-erstellen",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.4 Ein tibble erstellen",
    "text": "4.4 Ein tibble erstellen\nUm ein tibble zu erstellen, nutzen wir die Funktion tibble() und z√§hlen auf, welche Variablen wir dort haben m√∂chten.\n\ncar_numbers_short <- tibble(Land = car_numbers$geo, Zeit = car_numbers$time)\n\nIn dem Datensatz car_numbers_short haben wir jetzt die beiden Variablen geo und time aus dem Datensatz car_numbers als tibble abgespeichert."
  },
  {
    "objectID": "04-einlesen.html#daten-aus-r-speichern",
    "href": "04-einlesen.html#daten-aus-r-speichern",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.5 Daten aus R speichern",
    "text": "4.5 Daten aus R speichern\nWir speichern dieses tibble als Textdatei. Daf√ºr nutzen wir die Funktion write_delim(), die ebenfalls in der Bibliothek readr in tidyverse vorhanden ist. Achten Sie darauf, dass write_delim() nur tibble speichern kann. Wenn Sie einen Vektor (eine einzelne Variable) abspeichern m√∂chten, dann wandeln Sie diesen zuerst in ein tibble um.\n\nwrite_delim(x = car_numbers_short, file = 'Daten/geo.csv', delim = ';')"
  },
  {
    "objectID": "05-explorative-kategorial.html#mobilit√§t-in-europa",
    "href": "05-explorative-kategorial.html#mobilit√§t-in-europa",
    "title": "5¬† Exploration von kategorialen Daten",
    "section": "5.1 Mobilit√§t in Europa",
    "text": "5.1 Mobilit√§t in Europa\nWir nutzen erneut den Datensatz aus der ersten Sitzung der Vorlesung. Zun√§chst laden wir wie immer die n√∂tigen Bibliotheken.\n\nlibrary(tidyverse)\n\nDas Einlesen eines Datensatzes aus einer Textdatei haben Sie ja bereits im letzten Kapitel gelernt.\n\ncar_numbers <- read_delim(file = 'Daten/autos_2022-11-06.csv', delim = ';')\n\nRows: 76 Columns: 4\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \";\"\nchr  (2): geo, unit\ndbl  (1): values\ndate (1): time\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n5.1.1 Kategoriale Variablen als Faktoren\nWir sehen uns das tibble etwas genauer an.\n\ncar_numbers\n\n\n\n  \n\n\n\nKategorische Variablen werden als Text (character) eingelesen. Das bedeutet, dass wir R nicht (so leicht) fragen k√∂nnen, welche verschiedenen Merkmalsauspr√§gungen die Variable enth√§lt. Zur Erinnerung: Merkmalsauspr√§gungen sind die theoretisch m√∂glichen Werte, die eine Variable annehmen kann. Merkmalswert ist dann der tats√§chlich beobachtete Wert (die Beobachtung), den die Variable angenommen hat.\nEine bessere Klasse f√ºr eine kategoriale Variable ist ein Faktor (factor). Bei einem Faktor werden die unterschiedlichen Merkmalsauspr√§gungen (levels) explizit gespeichert. Wir wandeln daher die Text-Variable geo in einen Faktor um.\n\ncar_numbers <- car_numbers %>% \n  mutate(geo_factor = as_factor(geo))\n\nDas Zeichen %>% hei√üt Pipe-Operator. Man spricht ihn als und dann aus. Mehr dazu lernen Sie im Tutorium. Hier reicht es, wenn Sie sich die Funktion des Pipe-Operators als ein Weitergeben oder ein √úbergeben des Objekts auf der linken Seite des Pipe-Operators (also car_numbers) an die erste Stelle der Funktion in der neuen Zeile (bzw. rechts vom Pipe-Operator, also an die Funktion mutate()) vorstellen. Das bedeutet, dass man den Code oben auch wie folgt schreiben k√∂nnte:\n\ncar_numbers_test <- mutate(.data = car_numbers, geo_factor = as_factor(geo))\n\nEs kommt dasgleiche raus:\n\ncar_numbers\n\n\n\n  \n\n\ncar_numbers_test\n\n\n\n  \n\n\n\nDas ist aber viel un√ºbersichtlicher als mit dem Pipe-Operator. Da dieser den Code so sch√∂n strukturiert, wird er h√§ufig verwendet und ist ein fester Bestandteil von tidyverse.\nDie Funktion mutate() kann neue Variablen in einem Datensatz erstellen, ver√§ndern oder l√∂schen. In unserem Fall erstellen wir eine neue Variable, die wir geo_factor nennen. Die Funktion as_factor() wandelt (konvertiert) die Text-Variable geo in einen Faktor.\nDen Code car_numbers %>% mutate(geo_factor = as_factor(geo)) kann man also aussprechen als:\n\nNimm den Datensatz car_numbers und dann\nerstelle darin eine neue Variable geo_factor, in der die Variable geo als Faktor abgespeichert wird.\n\nDen Pipe-Operator erh√§lt man mit der Tastenkombination Str+Shift+M.\nDie Funktion mutate() f√ºgt neue Variablen am Ende des Datensatzes ein:\n\ncar_numbers\n\n\n\n  \n\n\n\nNun k√∂nnen wir R auch fragen, welche verschiedenen Merkmalsauspr√§gungen (levels) diese Variable enth√§lt:\n\nlevels(car_numbers$geo_factor)\n\n [1] \"Albania\"         \"Austria\"         \"Belgium\"         \"Bulgaria\"       \n [5] \"Croatia\"         \"Cyprus\"          \"Czechia\"         \"Denmark\"        \n [9] \"Estonia\"         \"Finland\"         \"France\"          \"Germany\"        \n[13] \"Greece\"          \"Hungary\"         \"Iceland\"         \"Ireland\"        \n[17] \"Italy\"           \"Kosovo\"          \"Latvia\"          \"Liechtenstein\"  \n[21] \"Lithuania\"       \"Luxembourg\"      \"Malta\"           \"Montenegro\"     \n[25] \"Netherlands\"     \"North Macedonia\" \"Norway\"          \"Poland\"         \n[29] \"Portugal\"        \"Romania\"         \"Serbia\"          \"Slovakia\"       \n[33] \"Slovenia\"        \"Spain\"           \"Sweden\"          \"Switzerland\"    \n[37] \"T√ºrkiye\"         \"United Kingdom\" \n\n\nDie einzelnen Merkmalsauspr√§gungen sind die verschiedenen L√§nder. Der Datensatz enth√§lt 38 unterschiedliche L√§nder.\n\n\n5.1.2 Balkendiagramm mit geom_col()\nWir m√∂chten die Daten als Balkendiagramm darstellen. Das Ziel ist eine √§hnliche Darstellung, wie in der Vorlesung.\n\n\n\n\n\nDaf√ºr m√ºssen wir zuerst eine neue Variable erstellen, die wir zum Einf√§rben der Jahre nutzen k√∂nnen. Dazu ben√∂tigen wir eine zus√§tzliche Bibliothek, die uns den Umgang mit Datum und Uhrzeit erleichtert. Sie hei√üt lubridate.\n\nlibrary(lubridate)\n\nNun nutzen wir die Funktion year() aus lubridate, um aus der Variablen time nur das Jahr zu extrahieren. Wir erstellen dazu mit mutate() wieder eine neue Variable, die wir time_year nennen.\n\ncar_numbers <- car_numbers %>% \n  mutate(time_year = year(time))\n\nAuch diese Variable wir an das Ende des Datensatzes car_numbers gestellt.\n\ncar_numbers\n\n\n\n  \n\n\n\nEine Variable zum Einf√§rben mit zwei verschiedenen Farben (je Jahr eine andere Farbe) muss kategorial sein. Die Variable time_year ist aber numerisch. Daher nutzen wir mutate(), um time_year in einen Faktor zu verwandeln.\n\ncar_numbers <- car_numbers %>% \n  mutate(time_year = as_factor(time_year))\n\nIn diesem Fall erstellt mutate() keine neue Variable, sondern √ºberschreibt (ver√§ndert) die vorhandene Variable time_year. Das ist m√∂glich und g√§ngige Praxis in R. Jetzt ist time_year ein Faktor, was man auch in der Darstellung des tibble sehen kann.\n\ncar_numbers\n\n\n\n  \n\n\n\nNun geht es an die Darstellung. Im Kapitel ?sec-ggplot haben Sie das geom_bar() kennengelernt. Es kann die Anzahl der Eintr√§ge in einer Variablen ausz√§hlen und diese als Balkendiagramm darstellen. Das m√∂chten wir aber in unserem Fall nicht. Wir wollen die Anzahl der Autos darstellen, die in der Variablen value enthalten ist. In anderen Worten, wir wollen die Merkmalswerte (Beobachtungen) selbst und und nicht deren Anzahl (counts) darstellen. Das ist die Aufgabe des geom_col() (col steht f√ºr columns, also S√§ulen/Balken).\n\nggplot(data = car_numbers, mapping = aes(x = geo, y = values, fill = time_year)) +\n  geom_col()\n\n\n\n\nEs ist noch etwas Nacharbeit n√∂tig. Sieht man in die Hilfe von geom_col(), dann kann man nachlesen, dass es standardm√§√üig ein Stapelbalkendiagramm darstellt (stacked bar plot ). M√∂chte man die Balken nebeneinander haben (dodged bar plot), muss man das explizit sagen.\n\nggplot(data = car_numbers, mapping = aes(x = geo, y = values, fill = time_year)) +\n  geom_col(position = position_dodge()) \n\n\n\n\nDie L√§ndernamen erscheinen (wie es Standard ist) horizontal. In unserem Fall √ºberdecken sie sich aber und wir sollten sie vertikal schreiben. Dazu gibt es eine neue Funktion aus ggplot2, die wie alle anderen mit einem + angeh√§ngt wird. Sie hei√üt theme(). Der Parameter, der f√ºr die Gestaltung der \\(x\\)-Achse zust√§ndig ist, hei√üt axis.text.x Die Funktion element_text mit der Einstellung angle = 90 dreht die einzelnen L√§nder um 90 Grad. Die Aufgabe der beiden anderen Parameter finden Sie im Rahmen der Aufgaben heraus.\n\nggplot(data = car_numbers, mapping = aes(x = geo, y = values, fill = time_year)) +\n  geom_col(position = position_dodge()) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))\n\nWarning: Removed 3 rows containing missing values (geom_col)."
  },
  {
    "objectID": "04-einlesen.html#eine-grafik-speichern",
    "href": "04-einlesen.html#eine-grafik-speichern",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.6 Eine Grafik speichern",
    "text": "4.6 Eine Grafik speichern"
  },
  {
    "objectID": "04-einlesen.html#einzelne-variablen-ansprechen",
    "href": "04-einlesen.html#einzelne-variablen-ansprechen",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.2 Einzelne Variablen ansprechen",
    "text": "4.2 Einzelne Variablen ansprechen\nJede Variable hat einen Namen. Man kann diesen nutzen, um die Variable anzusprechen. Z. B. k√∂nnten wir die Variable geo so ansprechen:\n\ncar_numbers$geo\n\n [1] \"Albania\"         \"Albania\"         \"Austria\"         \"Austria\"        \n [5] \"Belgium\"         \"Belgium\"         \"Bulgaria\"        \"Bulgaria\"       \n [9] \"Croatia\"         \"Croatia\"         \"Cyprus\"          \"Cyprus\"         \n[13] \"Czechia\"         \"Czechia\"         \"Denmark\"         \"Denmark\"        \n[17] \"Estonia\"         \"Estonia\"         \"Finland\"         \"Finland\"        \n[21] \"France\"          \"France\"          \"Germany\"         \"Germany\"        \n[25] \"Greece\"          \"Greece\"          \"Hungary\"         \"Hungary\"        \n[29] \"Iceland\"         \"Iceland\"         \"Ireland\"         \"Ireland\"        \n[33] \"Italy\"           \"Italy\"           \"Kosovo\"          \"Kosovo\"         \n[37] \"Latvia\"          \"Latvia\"          \"Liechtenstein\"   \"Liechtenstein\"  \n[41] \"Lithuania\"       \"Lithuania\"       \"Luxembourg\"      \"Luxembourg\"     \n[45] \"Malta\"           \"Malta\"           \"Montenegro\"      \"Montenegro\"     \n[49] \"Netherlands\"     \"Netherlands\"     \"North Macedonia\" \"North Macedonia\"\n[53] \"Norway\"          \"Norway\"          \"Poland\"          \"Poland\"         \n[57] \"Portugal\"        \"Portugal\"        \"Romania\"         \"Romania\"        \n[61] \"Serbia\"          \"Serbia\"          \"Slovakia\"        \"Slovakia\"       \n[65] \"Slovenia\"        \"Slovenia\"        \"Spain\"           \"Spain\"          \n[69] \"Sweden\"          \"Sweden\"          \"Switzerland\"     \"Switzerland\"    \n[73] \"T√ºrkiye\"         \"T√ºrkiye\"         \"United Kingdom\"  \"United Kingdom\" \n\n\nSie sehen, dass die Darstellung jetzt anders aussieht, weil eine einzelne Variable ein Vektor ist und kein tibble. Vektoren werden (durchnummeriert) ausgegeben und wir sehen alle 76 Eintr√§ge (L√§nder) nacheinander in der Reihenfolge ihres Erscheinens in der Variablen geo."
  },
  {
    "objectID": "04-einlesen.html#die-umfrage-aus-der-ersten-sitzung",
    "href": "04-einlesen.html#die-umfrage-aus-der-ersten-sitzung",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.8 Die Umfrage aus der ersten Sitzung",
    "text": "4.8 Die Umfrage aus der ersten Sitzung\nLesen Sie die Datei ‚ÄòUmfrage_2022_kurz.csv‚Äô ein. Sie enth√§lt die Umfrageergebnisse aus der ersten Session der Vorlesung zur Frage ‚ÄòHaben Sie schon mal einen Statistikkurs besucht?‚Äô\n\n\n\n\nWie viele Eintr√§ge enth√§lt der Datensatz?\nWie viele Variablen enth√§lt der Datensatz?\nSind die Variablen numerisch oder kategorial?\nErkl√§ren Sie jede Variable. Welche Information enth√§lt sie?\nStellen Sie die Antworten auf die Frage als Balkendiagramm dar. Es soll wie folgt aussehen:\n\n\n\n\n\n\n\nWie viele Teilnehmende haben bereits einen Statistikkurs besucht (ungef√§hr)?"
  },
  {
    "objectID": "05-explorative-kategorial.html#lending-club-peer-to-peer-kredite",
    "href": "05-explorative-kategorial.html#lending-club-peer-to-peer-kredite",
    "title": "5¬† Exploration von kategorialen Daten",
    "section": "5.2 Lending Club ‚Äì Peer-to-Peer-Kredite",
    "text": "5.2 Lending Club ‚Äì Peer-to-Peer-Kredite\nLending Club: Ein US-Unternehmen, das Individuen √ºber eine Plattform erm√∂glicht, an andere Individuen Geld zu verleihen (Peer-to-Peer-Kredite). Wir haben den Datensatz bereits in der Vorlesung kennengelernt. Er ist in der Bibliothek openintro als loands_full_schema zu finden. Wir laden die Bibliothek und holen uns den Datensatz.\n\n# Das R-Paket (auch Bibliothek genannt) laden\nlibrary(openintro)\n\n# Datensatz laden\ndata(loans_full_schema)\n\n# Datensatz ansehen\nglimpse(loans_full_schema)\n\nRows: 10,000\nColumns: 55\n$ emp_title                        <chr> \"global config engineer \", \"warehouse‚Ä¶\n$ emp_length                       <dbl> 3, 10, 3, 1, 10, NA, 10, 10, 10, 3, 1‚Ä¶\n$ state                            <fct> NJ, HI, WI, PA, CA, KY, MI, AZ, NV, I‚Ä¶\n$ homeownership                    <fct> MORTGAGE, RENT, RENT, RENT, RENT, OWN‚Ä¶\n$ annual_income                    <dbl> 90000, 40000, 40000, 30000, 35000, 34‚Ä¶\n$ verified_income                  <fct> Verified, Not Verified, Source Verifi‚Ä¶\n$ debt_to_income                   <dbl> 18.01, 5.04, 21.15, 10.16, 57.96, 6.4‚Ä¶\n$ annual_income_joint              <dbl> NA, NA, NA, NA, 57000, NA, 155000, NA‚Ä¶\n$ verification_income_joint        <fct> , , , , Verified, , Not Verified, , ,‚Ä¶\n$ debt_to_income_joint             <dbl> NA, NA, NA, NA, 37.66, NA, 13.12, NA,‚Ä¶\n$ delinq_2y                        <int> 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0‚Ä¶\n$ months_since_last_delinq         <int> 38, NA, 28, NA, NA, 3, NA, 19, 18, NA‚Ä¶\n$ earliest_credit_line             <dbl> 2001, 1996, 2006, 2007, 2008, 1990, 2‚Ä¶\n$ inquiries_last_12m               <int> 6, 1, 4, 0, 7, 6, 1, 1, 3, 0, 4, 4, 8‚Ä¶\n$ total_credit_lines               <int> 28, 30, 31, 4, 22, 32, 12, 30, 35, 9,‚Ä¶\n$ open_credit_lines                <int> 10, 14, 10, 4, 16, 12, 10, 15, 21, 6,‚Ä¶\n$ total_credit_limit               <int> 70795, 28800, 24193, 25400, 69839, 42‚Ä¶\n$ total_credit_utilized            <int> 38767, 4321, 16000, 4997, 52722, 3898‚Ä¶\n$ num_collections_last_12m         <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ num_historical_failed_to_pay     <int> 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0‚Ä¶\n$ months_since_90d_late            <int> 38, NA, 28, NA, NA, 60, NA, 71, 18, N‚Ä¶\n$ current_accounts_delinq          <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ total_collection_amount_ever     <int> 1250, 0, 432, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n$ current_installment_accounts     <int> 2, 0, 1, 1, 1, 0, 2, 2, 6, 1, 2, 1, 2‚Ä¶\n$ accounts_opened_24m              <int> 5, 11, 13, 1, 6, 2, 1, 4, 10, 5, 6, 7‚Ä¶\n$ months_since_last_credit_inquiry <int> 5, 8, 7, 15, 4, 5, 9, 7, 4, 17, 3, 4,‚Ä¶\n$ num_satisfactory_accounts        <int> 10, 14, 10, 4, 16, 12, 10, 15, 21, 6,‚Ä¶\n$ num_accounts_120d_past_due       <int> 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, ‚Ä¶\n$ num_accounts_30d_past_due        <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ num_active_debit_accounts        <int> 2, 3, 3, 2, 10, 1, 3, 5, 11, 3, 2, 2,‚Ä¶\n$ total_debit_limit                <int> 11100, 16500, 4300, 19400, 32700, 272‚Ä¶\n$ num_total_cc_accounts            <int> 14, 24, 14, 3, 20, 27, 8, 16, 19, 7, ‚Ä¶\n$ num_open_cc_accounts             <int> 8, 14, 8, 3, 15, 12, 7, 12, 14, 5, 8,‚Ä¶\n$ num_cc_carrying_balance          <int> 6, 4, 6, 2, 13, 5, 6, 10, 14, 3, 5, 3‚Ä¶\n$ num_mort_accounts                <int> 1, 0, 0, 0, 0, 3, 2, 7, 2, 0, 2, 3, 3‚Ä¶\n$ account_never_delinq_percent     <dbl> 92.9, 100.0, 93.5, 100.0, 100.0, 78.1‚Ä¶\n$ tax_liens                        <int> 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ public_record_bankrupt           <int> 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0‚Ä¶\n$ loan_purpose                     <fct> moving, debt_consolidation, other, de‚Ä¶\n$ application_type                 <fct> individual, individual, individual, i‚Ä¶\n$ loan_amount                      <int> 28000, 5000, 2000, 21600, 23000, 5000‚Ä¶\n$ term                             <dbl> 60, 36, 36, 36, 36, 36, 60, 60, 36, 3‚Ä¶\n$ interest_rate                    <dbl> 14.07, 12.61, 17.09, 6.72, 14.07, 6.7‚Ä¶\n$ installment                      <dbl> 652.53, 167.54, 71.40, 664.19, 786.87‚Ä¶\n$ grade                            <fct> C, C, D, A, C, A, C, B, C, A, C, B, C‚Ä¶\n$ sub_grade                        <fct> C3, C1, D1, A3, C3, A3, C2, B5, C2, A‚Ä¶\n$ issue_month                      <fct> Mar-2018, Feb-2018, Feb-2018, Jan-201‚Ä¶\n$ loan_status                      <fct> Current, Current, Current, Current, C‚Ä¶\n$ initial_listing_status           <fct> whole, whole, fractional, whole, whol‚Ä¶\n$ disbursement_method              <fct> Cash, Cash, Cash, Cash, Cash, Cash, C‚Ä¶\n$ balance                          <dbl> 27015.86, 4651.37, 1824.63, 18853.26,‚Ä¶\n$ paid_total                       <dbl> 1999.330, 499.120, 281.800, 3312.890,‚Ä¶\n$ paid_principal                   <dbl> 984.14, 348.63, 175.37, 2746.74, 1569‚Ä¶\n$ paid_interest                    <dbl> 1015.19, 150.49, 106.43, 566.15, 754.‚Ä¶\n$ paid_late_fees                   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n\n\n\n5.2.1 H√§ufigkeitstabelle\nWir erstellen eine H√§ufigkeitstabelle der Variable homeownership. Dazu m√ºssen wir die einzelnen Merkmalswerte ausz√§hlen lassen. Das √ºbernimmt die Funktion count().\n\nloans_full_schema %>% \n  count(homeownership)\n\n\n\n  \n\n\n\nDie Tabelle sieht anders aus als in der Vorlesung. Das liegt daran, dass die Variable homeownership f√ºr die Vorlesung ver√§ndert wurde. Es ist n√§mlich st√∂rend, wenn die Merkmalsauspr√§gungen mit Gro√übuchstaben geschrieben werden. Au√üerdem macht es logisch Sinn, zuerst die gemieteten, dann die mit einer Hypothek belegten und zum Schluss die Eigentumsobjekte zu sehen. Das spiegelt in einer gewissen Weise das Risiko wider, dass ein Kredit nicht bedient werden kann. Achtung: Es ist trotzdem keine ordinal-skalierte Variable!\nWir √§ndern die Darstellung der Variablen homeownership. Um den Originaldatensatz nicht zu √ºberschreiben, erstellen wir einen neuen, den wir loans nennen.\n\nloans <- loans_full_schema %>%\n  mutate(homeownership = tolower(homeownership),\n         homeownership = fct_relevel(homeownership, \"rent\", \"mortgage\", \"own\"))\n\nSie sehen, dass man die beiden √Ñnderungen in einem Aufruf zu mutate() durchf√ºhren darf. Zuerst macht die Funktion tolower() aus den Gro√übuchstaben Kleinbuchstaben, danach √§nder die Funktion fct_relevel() die Reihenfolge der Merkmalsauspr√§gungen (levles). Jetzt entspricht das Ergebnis dem der Vorlesung.\n\nloans %>% \n  count(homeownership)\n\n\n\n  \n\n\n\n\n\n5.2.2 Kontingenztabelle\nEine Kontingenztabelle fasst zwei kategoriale Variablen zusammen. Jede Zeile zeigt die Anzahl der Kombinationen zwischen diesen Variablen.\n\nloans %>%\n  count(application_type, homeownership)\n\n\n\n  \n\n\n\nDie Tabelle sieht auch anders aus als in der Vorlesung. Sie ist n√§mlich tidy: jede Spalte ist eine Variable und jede Zeile ist eine Beobachtung. In diesem Fall m√∂chte man es aber eigentlich untidy dargestellt haben. Das ist einer der seltenen F√§lle, n√§mlich die Darstellung von Tabellen, wo das auch Sinn macht. Achtung, jetzt wird es nerdy ü§ì.\nWir formatieren die Tabelle von lang tidy auf breit und untidy. Dabei wandern die Eintr√§ge der Spalte homeowndership in die Breite und werden zu neuen Spalten. Die eintr√§ge in den Tabellenzellen kommen aus der Spalte n.\n\nloans %>%\n  count(application_type, homeownership) %>%\n  pivot_wider(names_from = homeownership, values_from = n)\n\n\n\n  \n\n\n\nJetzt fehlen nur noch die Zeilen- und Spaltensummen. Da hilft die Bibliothek janitor\n\nlibrary(janitor)\n\nloans %>%\n  count(application_type, homeownership) %>%\n  pivot_wider(names_from = homeownership, values_from = n) %>% \n  adorn_totals(where = c(\"row\", \"col\"))\n\n\n\n  \n\n\n\nBis auf wenige √§sthetische Griffe ist das jetzt das Gleiche wie in der Vorlesung üòÑ."
  },
  {
    "objectID": "04-einlesen.html#ansprechen-von-spalten-zeilen-und-zellen-in-einem-tibble",
    "href": "04-einlesen.html#ansprechen-von-spalten-zeilen-und-zellen-in-einem-tibble",
    "title": "4¬† Daten in R einlesen und aus R speichern",
    "section": "4.3 Ansprechen von Spalten, Zeilen und Zellen in einem tibble",
    "text": "4.3 Ansprechen von Spalten, Zeilen und Zellen in einem tibble\nEin tibble ist ein zwei-dimensionales Objekt: Es hat Zeilen (erste Dimension) und Spalten (zweite Dimension). Um so ein Objekt richtig anzusprechen, erweitern wir unsere Notation mit den eckigen Klammern. Jetzt brauchen wir n√§mlich zwei Indizes: einen Index f√ºr die Zeile und einen Index f√ºr die Spalte eines Eintrags. Wenn wir z. B. den dritten Eintrag in der ersten Spalte (Variable geo) sehen wollen, schreiben wir:\n\ncar_numbers[3, 1]\n\n\n\n  \n\n\n\nEs handelt sich um √ñsterreich. Wir k√∂nnen auch ganze Spalten (Variablen) ansprechen. Daf√ºr wird der erste Index (f√ºr Zeilen) weggelassen. Nichts (oder ein Leerzeichen) signalisieren R, dass alle Eintr√§ge gemeint sind. So k√∂nnen wir die erste Spalte wie folgt ansprechen:\n\ncar_numbers[, 1]\n\n\n\n  \n\n\n\nBeim Ansprechen ganzer Zeilen ist es √§hnlich. Wir lassen den Index f√ºr die Spalte weg. Um die erste Zeile anzusprechen, schreiben wir:\n\ncar_numbers[1,]\n\n\n\n  \n\n\n\nSie sollten einen wichtigen Unterschied zwischen der $-Notation und dem Ansprechen in eckigen Klammern bemerken: Die $-Notation gibt einen Vektor zur√ºck. Wenn Sie ein tibble mit eckigen Klammern ansprechen, ist die Antwort ein tibble."
  },
  {
    "objectID": "20-aufgabensammlung.html#daten-in-r-einlesen-und-aus-r-speichern",
    "href": "20-aufgabensammlung.html#daten-in-r-einlesen-und-aus-r-speichern",
    "title": "Appendix A ‚Äî Aufgabensammlung",
    "section": "A.3 Daten in R einlesen und aus R speichern",
    "text": "A.3 Daten in R einlesen und aus R speichern\n\nA.3.1 Politbarometer 2021: Einlesen von Fremdformaten\nEs gibt viele verschiedene Statistikpakete (z. B. SAS, SPSS, Stata), die mit grafischen Oberfl√§chen arbeiten. Da die Analysen darin nicht reproducible sind (weil mit der Maus zusammengeklickt), empfehlen wir diese nicht. Dennoch gibt es manchmal interessante Datens√§tze, die in den Formaten dieser Statistikpakete vorliegen. ACHTUNG: Diese Aufgabe ist anspruchsvoll!\nIn dieser √úbung lernen Sie das Paket haven kennen, dass solche Formate einlesen kann. Haven ist Teil von tidyverse, muss aber extra installiert und geladen werden.\n\nLaden Sie die Bibliotheken tidyverse und haven.\n\nWir besch√§ftigen uns mit dem Datensatz ‚ÄúPolitbarometer 2021‚Äù. Die Politbarometer kennen Sie bestimmt aus dem ZDF. Das sind Telefonumfragen, die seit 1977 etwa monatlich von der Forschungsgruppe Wahlen f√ºr das ZDF durchgef√ºhrt werden. Wir sehen uns die Daten aus dem Jahr 2021 an. Sie sind f√ºr Lehre und Forschung frei. Sie m√ºssen Sie jedoch selbst herunterladen, die Nutzungsbedingungen lesen und ihnen zustimmen. Die Daten gibt es hier: http://dx.doi.org/10.4232/1.13909.\n\nLaden Sie unter ‚ÄúDownloads‚Äù (rechts oben) den Datensatz ‚ÄúZA7856_v1-0-0.dta.zip Stata (Dataset) 1.9 MB‚Äù herunter. Daf√ºr werden Sie sich einmalig (und kostenlos) anmelden m√ºssen.\n\nDas ist ein komprimierter Datensatz des Statistikpakets Stata. Speichern Sie den Datensatz in Ihrem ‚ÄúDaten‚Äù-Ordner und entpacken Sie ihn dort. Es wird ein Ordner namens ZA7856_v1-0-0.dta erstellt, in dem Sie die Datei ‚ÄúZA7856_v1-0-0.dta‚Äù finden. Das ist der eigentliche Datensatz.\n\nDatensatz einlesen mit der Funktion read_dta(). Passen Sie den Pfad zur Datei an, da ich f√ºr die √úbung eine andere Verzeichnisstruktur habe!\n\n\ngesis <- read_dta('Daten/ZA7856_v1-0-0.dta/ZA7856_v1-0-0.dta')\n\n\nWie viele Beobachtungen und Variablen enth√§lt der Datensatz?\nDie Variablennamen sind nichtssagend. Um den Datensatz zu verstehen, laden Sie auf der GESIS-Seite das Codebook herunter (rechts oben bei Downloads). Die Variablennamen sind in der ‚ÄúTabelle 1: Variablenkorrespondenzliste Politbarometer 2021‚Äù gelistet.\nWir werden gemeinsam die Variablen richtig umbenennen und die kategorialen Variablen zu Faktoren √§ndern. Gehen Sie durch den Code Zeile f√ºr Zeile durch und erkl√§ren Sie, was dieser macht.\n\n\ngesis_short <- gesis %>% \n  rename(Befragtennummer = V2,\n         Erhebungsmonat = V4,\n         Erhebungswoche = V5,\n         Bundesland = V6,\n         Erhebungsgebiet = V7,\n         Einwohner = V8,\n         Polit_interesse = V124) %>%\n  mutate(Erhebungsmonat = as_factor(Erhebungsmonat),\n         Erhebungswoche = as_factor(Erhebungswoche),\n         Bundesland = as_factor(Bundesland),\n         Erhebungsgebiet = as_factor(Erhebungsgebiet),\n         Einwohner = as_factor(Einwohner),\n         Polit_interesse = as_factor(Polit_interesse)\n         ) %>% \n  select(Befragtennummer,\n         Erhebungsmonat,\n         Erhebungswoche,\n         Bundesland,\n         Erhebungsgebiet,\n         Einwohner,\n         Polit_interesse)\n\n\nWie hat sich der Typ der kategorialen Variablen im Datensatz gesis_short gegen√ºber dem urspr√ºnglichen Datensatz gesis ver√§ndert?\nSpeichern Sie den neuen Datensatz gesis_short mit write_delim() ab."
  },
  {
    "objectID": "20-aufgabensammlung.html#exploration-von-kategorialen-daten",
    "href": "20-aufgabensammlung.html#exploration-von-kategorialen-daten",
    "title": "Appendix A ‚Äî Aufgabensammlung",
    "section": "A.4 Exploration von kategorialen Daten",
    "text": "A.4 Exploration von kategorialen Daten\n\nA.4.1 Politbarometer 2021: Das Interesse f√ºr Politik\nWir analysieren den Datensatz, den Sie in der vorherigen √úbung geladen und vorbereitet haben.\n\nLaden Sie nun den kurzen Datensatz gesis_short mit der passenden Bibliothek ein. Sie m√ºssen vorher nat√ºrlich diese Bibliothek mit library() laden.\n\n\n\n\n\nUntersuchen Sie den Datensatz nach dem Laden. Wie sind die kategorialen Variablen kodiert (chr odr fct)? Warum? Sehen Sie in der Hilfe von read_delim nach.\nWir m√ºssen nach dem Einlesen die kategorialen Variablen erneut in Faktoren umwandeln. Diese Information geht durch das Speichern mit write_delim() und das erneute Einlesen mit read_delim() verloren. Wandeln Sie die Variable Bundesland in einen Faktor um. Wenn Sie mit der Funktion as_fcator() arbeiten, ist die Reihenfolge der Merkmalsauspr√§gungen (der unterschiedlichen Werte einer kategorialen Variablen) standardm√§√üig so, wie diese im Datensatz erscheinen. Das ist f√ºr die Bundesl√§nder ausreichend.\nWie viele Personen wurden pro Bundesland im Politbarometer im Jahr 2021 befragt?\nWir wollen nun wissen, wie das Politikinteresse in den Bundesl√§ndern ausgepr√§gt ist. Daf√ºr sehen wir uns die Antworten auf die Frage ‚ÄúWie stark interessieren Sie sich f√ºr Politik, ‚Ä¶‚Äù. Die Antworten sind in der Variablen Polit_Interesse enthalten. Wie haben die Befragten abgestimmt?\nDie Reihenfolge der Merkmalsauspr√§gungen ist unlogisch. Das m√ºssen wir √§ndern. Bei dieser Variablen gibt es eine logische Reihenfolge: Sehr stark, stark, etwas, kaum, gar nicht, KA. Letzteres steht f√ºr keine Angabe. Nutzen Sie den folgenden Code, um die Variable Polit_interesse in einen Faktor mit richtiger Reihenfolge der Merkmalsauspr√§gungen umzuwandeln.\n\n\ngesis_short <- gesis_short %>% \n  mutate(gesis_short <- gesis_short %>% \n  mutate(Polit_interesse = factor(Polit_interesse, levels = c('Sehr stark', 'stark', 'etwas', 'kaum', 'gar nicht', 'KA'))))\n\nWiederholen Sie nun die Aufgabe 5.\n\nVergleichen Sie die Antworten zwischen den Bundesl√§ndern. Ist das Interesse der B√ºrger √§hnlich? Warum ist das schwer zu beantworten?\nWir pirschen uns an die relativen H√§ufigkeiten heran. Was macht der nachfolgende Code. Sehen Sie gegebenenfalls in der Hilfe nach.\n\n\ngesis_short %>% \n  count(Bundesland, Polit_interesse) %>% \n  pivot_wider(names_from = Bundesland, values_from = n)\n\nDer n√§chste Schritt ist es, die relativen H√§ufigkeiten (Anteile) f√ºr jedes Bundesland auszurechnen, um die obige Frage zu beantworten. Erkl√§ren Sie, was der nachfolgende Code macht:\n\ngesis_short %>% \n  count(Bundesland, Polit_interesse) %>% \n  group_by(Bundesland) %>%\n  mutate(Anteil = n / sum(n)) %>% \n  select(-n) %>% \n  pivot_wider(names_from = Bundesland, values_from = Anteil)\n\nZur√ºck zu unserer Frage: Ist das Interesse der B√ºrger in allen Bundesl√§ndern √§hnlich?\n\nBeantworten Sie die Frage jetzt auch grafisch, indem Sie ein Balkendiagramm plotten. Es soll so aussehen:\n\n\n\n\n\n\nDaf√ºr k√∂nnen Sie folgende Code-Fragmente erg√§nzen:\n\nggplot(data = ___, mapping = aes(y = ___, fill = ___)) +\n  geom_bar(position = position_fill(reverse = TRUE)) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +\n  labs(___)\n\nWas macht geom_bar(position = position_fill(reverse = TRUE))?\n\n\n\n\nZuur, A. F., E. Ieno, and E. Meesters. 2009. A Beginner‚Äôs Guide to R. Springer."
  },
  {
    "objectID": "30-lab-02-intro-to-data.html",
    "href": "30-lab-02-intro-to-data.html",
    "title": "8¬† Lab 02: P√ºnktlichkeit von Fl√ºgen",
    "section": "",
    "text": "Das ist die deutsche √úbersetzung des ‚ÄúOpenIntro Labs for R and tidyverse‚Äù 2. Intro to data. Es ist Teil des Buches von √áetinkaya-Rundel et al., Introduction to Modern Statistics, lizenziert unter CC-BY-SA 3.0. √úbersetzt mit www.DeepL.com/Translator, bearbeitet und erg√§nzt von C. Bogner und L. Dedeke.\nManche definieren Statistik als das Gebiet, das sich darauf konzentriert, Informationen in Wissen zu verwandeln. Der erste Schritt in diesem Prozess ist die Zusammenfassung und Beschreibung der Rohinformationen - der Daten. In dieser √úbung untersuchen wir Fl√ºge, insbesondere eine Zufallsstichprobe von Inlandsfl√ºgen, die im Jahr 2013 von den drei gro√üen Flugh√§fen in New York City abgeflogen sind. Wir werden einfache grafische und numerische Zusammenfassungen der Daten zu diesen Fl√ºgen erstellen und die Versp√§tungszeiten untersuchen. Da es sich um einen gro√üen Datensatz handelt, werden Sie nebenbei auch die unverzichtbaren Fertigkeiten der Datenverarbeitung und -unterteilung erlernen."
  },
  {
    "objectID": "30-lab-02-intro-to-data.html#mobilit√§t-in-europa",
    "href": "30-lab-02-intro-to-data.html#mobilit√§t-in-europa",
    "title": "6¬† Lab 02: Einf√ºhrung in Daten",
    "section": "6.1 Mobilit√§t in Europa",
    "text": "6.1 Mobilit√§t in Europa\nWir nutzen erneut den Datensatz aus der ersten Sitzung der Vorlesung. Zun√§chst laden wir wie immer die n√∂tigen Bibliotheken.\n\nlibrary(tidyverse)\n\nDas Einlesen eines Datensatzes aus einer Textdatei haben Sie ja bereits im letzten Kapitel gelernt.\n\ncar_numbers <- read_delim(file = 'Daten/autos_2022-11-06.csv', delim = ';')\n\nRows: 76 Columns: 4\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \";\"\nchr  (2): geo, unit\ndbl  (1): values\ndate (1): time\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n6.1.1 Kategoriale Variablen als Faktoren\nWir sehen uns das tibble etwas genauer an.\n\ncar_numbers\n\n\n\n  \n\n\n\nKategorische Variablen werden als Text (character) eingelesen. Das bedeutet, dass wir R nicht (so leicht) fragen k√∂nnen, welche verschiedenen Merkmalsauspr√§gungen die Variable enth√§lt. Zur Erinnerung: Merkmalsauspr√§gungen sind die theoretisch m√∂glichen Werte, die eine Variable annehmen kann. Merkmalswert ist dann der tats√§chlich beobachtete Wert (die Beobachtung), den die Variable angenommen hat.\nEine bessere Klasse f√ºr eine kategoriale Variable ist ein Faktor (factor). Bei einem Faktor werden die unterschiedlichen Merkmalsauspr√§gungen (levels) explizit gespeichert. Wir wandeln daher die Text-Variable geo in einen Faktor um.\n\ncar_numbers <- car_numbers %>% \n  mutate(geo_factor = as_factor(geo))\n\nDas Zeichen %>% hei√üt Pipe-Operator. Man spricht ihn als und dann aus. Mehr dazu lernen Sie im Tutorium. Hier reicht es, wenn Sie sich die Funktion des Pipe-Operators als ein Weitergeben oder ein √úbergeben des Objekts auf der linken Seite des Pipe-Operators (also car_numbers) an die erste Stelle der Funktion in der neuen Zeile (bzw. rechts vom Pipe-Operator, also an die Funktion mutate()) vorstellen. Das bedeutet, dass man den Code oben auch wie folgt schreiben k√∂nnte:\n\ncar_numbers_test <- mutate(.data = car_numbers, geo_factor = as_factor(geo))\n\nEs kommt dasgleiche raus:\n\ncar_numbers\n\n\n\n  \n\n\ncar_numbers_test\n\n\n\n  \n\n\n\nDas ist aber viel un√ºbersichtlicher als mit dem Pipe-Operator. Da dieser den Code so sch√∂n strukturiert, wird er h√§ufig verwendet und ist ein fester Bestandteil von tidyverse.\nDie Funktion mutate() kann neue Variablen in einem Datensatz erstellen, ver√§ndern oder l√∂schen. In unserem Fall erstellen wir eine neue Variable, die wir geo_factor nennen. Die Funktion as_factor() wandelt (konvertiert) die Text-Variable geo in einen Faktor.\nDen Code car_numbers %>% mutate(geo_factor = as_factor(geo)) kann man also aussprechen als:\n\nNimm den Datensatz car_numbers und dann\nerstelle darin eine neue Variable geo_factor, in der die Variable geo als Faktor abgespeichert wird.\n\nDen Pipe-Operator erh√§lt man mit der Tastenkombination Str+Shift+M.\nDie Funktion mutate() f√ºgt neue Variablen am Ende des Datensatzes ein:\n\ncar_numbers\n\n\n\n  \n\n\n\nNun k√∂nnen wir R auch fragen, welche verschiedenen Merkmalsauspr√§gungen (levels) diese Variable enth√§lt:\n\nlevels(car_numbers$geo_factor)\n\n [1] \"Albania\"         \"Austria\"         \"Belgium\"         \"Bulgaria\"       \n [5] \"Croatia\"         \"Cyprus\"          \"Czechia\"         \"Denmark\"        \n [9] \"Estonia\"         \"Finland\"         \"France\"          \"Germany\"        \n[13] \"Greece\"          \"Hungary\"         \"Iceland\"         \"Ireland\"        \n[17] \"Italy\"           \"Kosovo\"          \"Latvia\"          \"Liechtenstein\"  \n[21] \"Lithuania\"       \"Luxembourg\"      \"Malta\"           \"Montenegro\"     \n[25] \"Netherlands\"     \"North Macedonia\" \"Norway\"          \"Poland\"         \n[29] \"Portugal\"        \"Romania\"         \"Serbia\"          \"Slovakia\"       \n[33] \"Slovenia\"        \"Spain\"           \"Sweden\"          \"Switzerland\"    \n[37] \"T√ºrkiye\"         \"United Kingdom\" \n\n\nDie einzelnen Merkmalsauspr√§gungen sind die verschiedenen L√§nder. Der Datensatz enth√§lt 38 unterschiedliche L√§nder.\n\n\n6.1.2 Balkendiagramm mit geom_col()\nWir m√∂chten die Daten als Balkendiagramm darstellen. Das Ziel ist eine √§hnliche Darstellung, wie in der Vorlesung.\n\n\n\n\n\nDaf√ºr m√ºssen wir zuerst eine neue Variable erstellen, die wir zum Einf√§rben der Jahre nutzen k√∂nnen. Dazu ben√∂tigen wir eine zus√§tzliche Bibliothek, die uns den Umgang mit Datum und Uhrzeit erleichtert. Sie hei√üt lubridate.\n\nlibrary(lubridate)\n\nNun nutzen wir die Funktion year() aus lubridate, um aus der Variablen time nur das Jahr zu extrahieren. Wir erstellen dazu mit mutate() wieder eine neue Variable, die wir time_year nennen.\n\ncar_numbers <- car_numbers %>% \n  mutate(time_year = year(time))\n\nAuch diese Variable wir an das Ende des Datensatzes car_numbers gestellt.\n\ncar_numbers\n\n\n\n  \n\n\n\nEine Variable zum Einf√§rben mit zwei verschiedenen Farben (je Jahr eine andere Farbe) muss kategorial sein. Die Variable time_year ist aber numerisch. Daher nutzen wir mutate(), um time_year in einen Faktor zu verwandeln.\n\ncar_numbers <- car_numbers %>% \n  mutate(time_year = as_factor(time_year))\n\nIn diesem Fall erstellt mutate() keine neue Variable, sondern √ºberschreibt (ver√§ndert) die vorhandene Variable time_year. Das ist m√∂glich und g√§ngige Praxis in R. Jetzt ist time_year ein Faktor, was man auch in der Darstellung des tibble sehen kann.\n\ncar_numbers\n\n\n\n  \n\n\n\nNun geht es an die Darstellung. Im Kapitel ?sec-ggplot haben Sie das geom_bar() kennengelernt. Es kann die Anzahl der Eintr√§ge in einer Variablen ausz√§hlen und diese als Balkendiagramm darstellen. Das m√∂chten wir aber in unserem Fall nicht. Wir wollen die Anzahl der Autos darstellen, die in der Variablen value enthalten ist. In anderen Worten, wir wollen die Merkmalswerte (Beobachtungen) selbst und und nicht deren Anzahl (counts) darstellen. Das ist die Aufgabe des geom_col() (col steht f√ºr columns, also S√§ulen/Balken).\n\nggplot(data = car_numbers, mapping = aes(x = geo, y = values, fill = time_year)) +\n  geom_col()\n\n\n\n\nEs ist noch etwas Nacharbeit n√∂tig. Sieht man in die Hilfe von geom_col(), dann kann man nachlesen, dass es standardm√§√üig ein Stapelbalkendiagramm darstellt (stacked bar plot ). M√∂chte man die Balken nebeneinander haben (dodged bar plot), muss man das explizit sagen.\n\nggplot(data = car_numbers, mapping = aes(x = geo, y = values, fill = time_year)) +\n  geom_col(position = position_dodge()) \n\n\n\n\nDie L√§ndernamen erscheinen (wie es Standard ist) horizontal. In unserem Fall √ºberdecken sie sich aber und wir sollten sie vertikal schreiben. Dazu gibt es eine neue Funktion aus ggplot2, die wie alle anderen mit einem + angeh√§ngt wird. Sie hei√üt theme(). Der Parameter, der f√ºr die Gestaltung der \\(x\\)-Achse zust√§ndig ist, hei√üt axis.text.x Die Funktion element_text mit der Einstellung angle = 90 dreht die einzelnen L√§nder um 90 Grad. Die Aufgabe der beiden anderen Parameter finden Sie im Rahmen der Aufgaben heraus.\n\nggplot(data = car_numbers, mapping = aes(x = geo, y = values, fill = time_year)) +\n  geom_col(position = position_dodge()) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))\n\nWarning: Removed 3 rows containing missing values (geom_col)."
  },
  {
    "objectID": "30-lab-02-intro-to-data.html#lending-club-peer-to-peer-kredite",
    "href": "30-lab-02-intro-to-data.html#lending-club-peer-to-peer-kredite",
    "title": "6¬† Lab 02: Einf√ºhrung in Daten",
    "section": "6.2 Lending Club ‚Äì Peer-to-Peer-Kredite",
    "text": "6.2 Lending Club ‚Äì Peer-to-Peer-Kredite\nLending Club: Ein US-Unternehmen, das Individuen √ºber eine Plattform erm√∂glicht, an andere Individuen Geld zu verleihen (Peer-to-Peer-Kredite). Wir haben den Datensatz bereits in der Vorlesung kennengelernt. Er ist in der Bibliothek openintro als loands_full_schema zu finden. Wir laden die Bibliothek und holen uns den Datensatz.\n\n# Das R-Paket (auch Bibliothek genannt) laden\nlibrary(openintro)\n\n# Datensatz laden\ndata(loans_full_schema)\n\n# Datensatz ansehen\nglimpse(loans_full_schema)\n\nRows: 10,000\nColumns: 55\n$ emp_title                        <chr> \"global config engineer \", \"warehouse‚Ä¶\n$ emp_length                       <dbl> 3, 10, 3, 1, 10, NA, 10, 10, 10, 3, 1‚Ä¶\n$ state                            <fct> NJ, HI, WI, PA, CA, KY, MI, AZ, NV, I‚Ä¶\n$ homeownership                    <fct> MORTGAGE, RENT, RENT, RENT, RENT, OWN‚Ä¶\n$ annual_income                    <dbl> 90000, 40000, 40000, 30000, 35000, 34‚Ä¶\n$ verified_income                  <fct> Verified, Not Verified, Source Verifi‚Ä¶\n$ debt_to_income                   <dbl> 18.01, 5.04, 21.15, 10.16, 57.96, 6.4‚Ä¶\n$ annual_income_joint              <dbl> NA, NA, NA, NA, 57000, NA, 155000, NA‚Ä¶\n$ verification_income_joint        <fct> , , , , Verified, , Not Verified, , ,‚Ä¶\n$ debt_to_income_joint             <dbl> NA, NA, NA, NA, 37.66, NA, 13.12, NA,‚Ä¶\n$ delinq_2y                        <int> 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0‚Ä¶\n$ months_since_last_delinq         <int> 38, NA, 28, NA, NA, 3, NA, 19, 18, NA‚Ä¶\n$ earliest_credit_line             <dbl> 2001, 1996, 2006, 2007, 2008, 1990, 2‚Ä¶\n$ inquiries_last_12m               <int> 6, 1, 4, 0, 7, 6, 1, 1, 3, 0, 4, 4, 8‚Ä¶\n$ total_credit_lines               <int> 28, 30, 31, 4, 22, 32, 12, 30, 35, 9,‚Ä¶\n$ open_credit_lines                <int> 10, 14, 10, 4, 16, 12, 10, 15, 21, 6,‚Ä¶\n$ total_credit_limit               <int> 70795, 28800, 24193, 25400, 69839, 42‚Ä¶\n$ total_credit_utilized            <int> 38767, 4321, 16000, 4997, 52722, 3898‚Ä¶\n$ num_collections_last_12m         <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ num_historical_failed_to_pay     <int> 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0‚Ä¶\n$ months_since_90d_late            <int> 38, NA, 28, NA, NA, 60, NA, 71, 18, N‚Ä¶\n$ current_accounts_delinq          <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ total_collection_amount_ever     <int> 1250, 0, 432, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n$ current_installment_accounts     <int> 2, 0, 1, 1, 1, 0, 2, 2, 6, 1, 2, 1, 2‚Ä¶\n$ accounts_opened_24m              <int> 5, 11, 13, 1, 6, 2, 1, 4, 10, 5, 6, 7‚Ä¶\n$ months_since_last_credit_inquiry <int> 5, 8, 7, 15, 4, 5, 9, 7, 4, 17, 3, 4,‚Ä¶\n$ num_satisfactory_accounts        <int> 10, 14, 10, 4, 16, 12, 10, 15, 21, 6,‚Ä¶\n$ num_accounts_120d_past_due       <int> 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, ‚Ä¶\n$ num_accounts_30d_past_due        <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ num_active_debit_accounts        <int> 2, 3, 3, 2, 10, 1, 3, 5, 11, 3, 2, 2,‚Ä¶\n$ total_debit_limit                <int> 11100, 16500, 4300, 19400, 32700, 272‚Ä¶\n$ num_total_cc_accounts            <int> 14, 24, 14, 3, 20, 27, 8, 16, 19, 7, ‚Ä¶\n$ num_open_cc_accounts             <int> 8, 14, 8, 3, 15, 12, 7, 12, 14, 5, 8,‚Ä¶\n$ num_cc_carrying_balance          <int> 6, 4, 6, 2, 13, 5, 6, 10, 14, 3, 5, 3‚Ä¶\n$ num_mort_accounts                <int> 1, 0, 0, 0, 0, 3, 2, 7, 2, 0, 2, 3, 3‚Ä¶\n$ account_never_delinq_percent     <dbl> 92.9, 100.0, 93.5, 100.0, 100.0, 78.1‚Ä¶\n$ tax_liens                        <int> 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ public_record_bankrupt           <int> 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0‚Ä¶\n$ loan_purpose                     <fct> moving, debt_consolidation, other, de‚Ä¶\n$ application_type                 <fct> individual, individual, individual, i‚Ä¶\n$ loan_amount                      <int> 28000, 5000, 2000, 21600, 23000, 5000‚Ä¶\n$ term                             <dbl> 60, 36, 36, 36, 36, 36, 60, 60, 36, 3‚Ä¶\n$ interest_rate                    <dbl> 14.07, 12.61, 17.09, 6.72, 14.07, 6.7‚Ä¶\n$ installment                      <dbl> 652.53, 167.54, 71.40, 664.19, 786.87‚Ä¶\n$ grade                            <fct> C, C, D, A, C, A, C, B, C, A, C, B, C‚Ä¶\n$ sub_grade                        <fct> C3, C1, D1, A3, C3, A3, C2, B5, C2, A‚Ä¶\n$ issue_month                      <fct> Mar-2018, Feb-2018, Feb-2018, Jan-201‚Ä¶\n$ loan_status                      <fct> Current, Current, Current, Current, C‚Ä¶\n$ initial_listing_status           <fct> whole, whole, fractional, whole, whol‚Ä¶\n$ disbursement_method              <fct> Cash, Cash, Cash, Cash, Cash, Cash, C‚Ä¶\n$ balance                          <dbl> 27015.86, 4651.37, 1824.63, 18853.26,‚Ä¶\n$ paid_total                       <dbl> 1999.330, 499.120, 281.800, 3312.890,‚Ä¶\n$ paid_principal                   <dbl> 984.14, 348.63, 175.37, 2746.74, 1569‚Ä¶\n$ paid_interest                    <dbl> 1015.19, 150.49, 106.43, 566.15, 754.‚Ä¶\n$ paid_late_fees                   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n\n\n\n6.2.1 H√§ufigkeitstabelle\nWir erstellen eine H√§ufigkeitstabelle der Variable homeownership. Dazu m√ºssen wir die einzelnen Merkmalswerte ausz√§hlen lassen. Das √ºbernimmt die Funktion count().\n\nloans_full_schema %>% \n  count(homeownership)\n\n\n\n  \n\n\n\nDie Tabelle sieht anders aus als in der Vorlesung. Das liegt daran, dass die Variable homeownership f√ºr die Vorlesung ver√§ndert wurde. Es ist n√§mlich st√∂rend, wenn die Merkmalsauspr√§gungen mit Gro√übuchstaben geschrieben werden. Au√üerdem macht es logisch Sinn, zuerst die gemieteten, dann die mit einer Hypothek belegten und zum Schluss die Eigentumsobjekte zu sehen. Das spiegelt in einer gewissen Weise das Risiko wider, dass ein Kredit nicht bedient werden kann. Achtung: Es ist trotzdem keine ordinal-skalierte Variable!\nWir √§ndern die Darstellung der Variablen homeownership. Um den Originaldatensatz nicht zu √ºberschreiben, erstellen wir einen neuen, den wir loans nennen.\n\nloans <- loans_full_schema %>%\n  mutate(homeownership = tolower(homeownership),\n         homeownership = fct_relevel(homeownership, \"rent\", \"mortgage\", \"own\"))\n\nSie sehen, dass man die beiden √Ñnderungen in einem Aufruf zu mutate() durchf√ºhren darf. Zuerst macht die Funktion tolower() aus den Gro√übuchstaben Kleinbuchstaben, danach √§nder die Funktion fct_relevel() die Reihenfolge der Merkmalsauspr√§gungen (levles). Jetzt entspricht das Ergebnis dem der Vorlesung.\n\nloans %>% \n  count(homeownership)\n\n\n\n  \n\n\n\n\n\n6.2.2 Kontingenztabelle\nEine Kontingenztabelle fasst zwei kategoriale Variablen zusammen. Jede Zeile zeigt die Anzahl der Kombinationen zwischen diesen Variablen.\n\nloans %>%\n  count(application_type, homeownership)\n\n\n\n  \n\n\n\nDie Tabelle sieht auch anders aus als in der Vorlesung. Sie ist n√§mlich tidy: jede Spalte ist eine Variable und jede Zeile ist eine Beobachtung. In diesem Fall m√∂chte man es aber eigentlich untidy dargestellt haben. Das ist einer der seltenen F√§lle, n√§mlich die Darstellung von Tabellen, wo das auch Sinn macht. Achtung, jetzt wird es nerdy ü§ì.\nWir formatieren die Tabelle von lang tidy auf breit und untidy. Dabei wandern die Eintr√§ge der Spalte homeowndership in die Breite und werden zu neuen Spalten. Die eintr√§ge in den Tabellenzellen kommen aus der Spalte n.\n\nloans %>%\n  count(application_type, homeownership) %>%\n  pivot_wider(names_from = homeownership, values_from = n)\n\n\n\n  \n\n\n\nJetzt fehlen nur noch die Zeilen- und Spaltensummen. Da hilft die Bibliothek janitor\n\nlibrary(janitor)\n\nloans %>%\n  count(application_type, homeownership) %>%\n  pivot_wider(names_from = homeownership, values_from = n) %>% \n  adorn_totals(where = c(\"row\", \"col\"))\n\n\n\n  \n\n\n\nBis auf wenige √§sthetische Griffe ist das jetzt das Gleiche wie in der Vorlesung üòÑ."
  },
  {
    "objectID": "30-lab-02-intro-to-data.html#aufgaben",
    "href": "30-lab-02-intro-to-data.html#aufgaben",
    "title": "6¬† Lab 02: Einf√ºhrung in Daten",
    "section": "6.3 Aufgaben",
    "text": "6.3 Aufgaben\n\n6.3.1 Grafik beschriften\nBeschriften Sie die finale Grafik aus Section¬†6.1.2 so, dass sie wie dort anfangs dargestellt aussieht.\n\n\n6.3.2 Aufgaben der Funktion theme()\n\nLesen Sie nach, was die Aufgabe der Funktion theme() ist. Fassen Sie den Abschnitt Description kurz mit Ihren eigenen Worten zusammen.\nIch habe in der Vorlesung theme_classic() benutzt. √Ñndern Sie die finale Grafik in Section¬†6.1.2 so, dass auch dort dieses theme benutzt wird.\nFinden Sie heraus, was hjust und vjust tun. Probieren Sie die Werte 0, 0.5 und 1 aus. Wie √§ndert sich die Position der L√§ndernamen?\n\n\n\n6.3.3 Tutorium\nBearbeiten Sie das Tutorium ‚ÄúEinf√ºhrung in Daten: 1 - Die Sprache der Daten‚Äù. Sie k√∂nnen entweder die deutsche √úbersetzung oder das englische Original bearbeiten. Das Tutorium muss nicht hochgeladen werden."
  },
  {
    "objectID": "30-lab-02-intro-to-data.html#ihre-arbeit-einreichen",
    "href": "30-lab-02-intro-to-data.html#ihre-arbeit-einreichen",
    "title": "6¬† Lab 02: Einf√ºhrung in Daten",
    "section": "6.4 Ihre Arbeit einreichen",
    "text": "6.4 Ihre Arbeit einreichen\n\nSpeichern Sie Ihr Notebook ab.\nLaden Sie Ihre .Rmd Datei in ILIAS hoch. Beachten Sie die Frist!\nSie erhalten die Musterl√∂sung nach dem Hochladen."
  },
  {
    "objectID": "100-aufgabensammlung.html",
    "href": "100-aufgabensammlung.html",
    "title": "Appendix A ‚Äî Aufgabensammlung",
    "section": "",
    "text": "In einer Studie wurden 1100 Spitzschwanzammer (Ammodramus caudacutus) vermessen. Wir nutzen einen Teil des Datensatzes (Zuur, Ieno, and Meesters 2009a). Die gemessenen Variablen sind Fluegel, Fuss (Tarsus), Kopf, Gewicht. Leider git die Datenquelle die Messeinheiten nicht an. Die Daten sind wie folgt:\n\n\n\n\n\n\n\n \n  \n    Fluegel \n    Fuss \n    Kopf \n    Gewicht \n  \n \n\n  \n    59.0 \n    22.3 \n    31.2 \n    9.5 \n  \n  \n    55.0 \n    19.7 \n    30.4 \n    13.8 \n  \n  \n    53.5 \n    20.8 \n    30.6 \n    14.8 \n  \n  \n    55.0 \n    20.3 \n    30.3 \n    15.2 \n  \n  \n    52.5 \n    20.8 \n    30.3 \n    15.5 \n  \n  \n    57.5 \n    21.5 \n    30.8 \n    15.6 \n  \n  \n    53.0 \n    20.6 \n    32.5 \n    15.6 \n  \n  \n    55.0 \n    21.5 \n    NA \n    15.7 \n  \n\n\n\n\n\n\nErstellen Sie jede Variable einzeln mithilfe der Funktion c().\nWie viele V√∂gel sind in der Tabelle zu finden. Nutzen Sie dazu die Funktion length(). Sehen Sie in der Hilfe nach, wie man diese benutzt.\nF√ºhren Sie alle Variablen zu einem einzelnen Datenobjekt, einem tibble zusammen mithilfe der Funktion tibble() aus dem R-Paket tibble."
  },
  {
    "objectID": "100-aufgabensammlung.html#einf√ºhrung-in-die-darstellung-von-daten",
    "href": "100-aufgabensammlung.html#einf√ºhrung-in-die-darstellung-von-daten",
    "title": "Appendix A ‚Äî Aufgabensammlung",
    "section": "A.2 Einf√ºhrung in die Darstellung von Daten",
    "text": "A.2 Einf√ºhrung in die Darstellung von Daten\n\nA.2.1 Pinguine\n\nLaden Sie die Bibliotheken tidyverse und palmerpenguins mithilfe der Funktion library().\nLaden Sie den Datensatz penguins mithilfe der Funktion data().\nSehen Sie sich den Datensatz an.\nPlotten Sie ein Streudiagramm der Variablen Flossenl√§nge flipper_length_mm auf der \\(x\\)-Achse und der Variablen K√∂rpergewicht body_mass_g auf der \\(y\\)-Achse.\nBeschriften Sie die Grafik sinnvoll.\nF√§rben Sie die Punkte je nach Art unterschiedlich ein mithilfe der Variablen species.\n\nSie sollten die gleiche (bis auf die Farbauswahl) Grafik erhalten, wie in der Vorlesung ü§ì."
  },
  {
    "objectID": "100-aufgabensammlung.html#daten-in-r-einlesen-und-aus-r-speichern",
    "href": "100-aufgabensammlung.html#daten-in-r-einlesen-und-aus-r-speichern",
    "title": "Appendix A ‚Äî Aufgabensammlung",
    "section": "A.3 Daten in R einlesen und aus R speichern",
    "text": "A.3 Daten in R einlesen und aus R speichern\n\nA.3.1 Politbarometer 2021: Einlesen von Fremdformaten\nEs gibt viele verschiedene Statistikpakete (z. B. SAS, SPSS, Stata), die mit grafischen Oberfl√§chen arbeiten. Da die Analysen darin nicht reproducible sind (weil mit der Maus zusammengeklickt), empfehlen wir diese nicht. Dennoch gibt es manchmal interessante Datens√§tze, die in den Formaten dieser Statistikpakete vorliegen. ACHTUNG: Diese Aufgabe ist anspruchsvoll!\nIn dieser √úbung lernen Sie das Paket haven kennen, dass solche Formate einlesen kann. Haven ist Teil von tidyverse, muss aber extra installiert und geladen werden.\n\nLaden Sie die Bibliotheken tidyverse und haven.\n\nWir besch√§ftigen uns mit dem Datensatz ‚ÄúPolitbarometer 2021‚Äù. Die Politbarometer kennen Sie bestimmt aus dem ZDF. Das sind Telefonumfragen, die seit 1977 etwa monatlich von der Forschungsgruppe Wahlen f√ºr das ZDF durchgef√ºhrt werden. Wir sehen uns die Daten aus dem Jahr 2021 an. Sie sind f√ºr Lehre und Forschung frei. Sie m√ºssen Sie jedoch selbst herunterladen, die Nutzungsbedingungen lesen und ihnen zustimmen. Die Daten gibt es hier: http://dx.doi.org/10.4232/1.13909.\n\nLaden Sie unter ‚ÄúDownloads‚Äù (rechts oben) den Datensatz ‚ÄúZA7856_v1-0-0.dta.zip Stata (Dataset) 1.9 MB‚Äù herunter. Daf√ºr werden Sie sich einmalig (und kostenlos) anmelden m√ºssen.\n\nDas ist ein komprimierter Datensatz des Statistikpakets Stata. Speichern Sie den Datensatz in Ihrem ‚ÄúDaten‚Äù-Ordner und entpacken Sie ihn dort. Es wird ein Ordner namens ZA7856_v1-0-0.dta erstellt, in dem Sie die Datei ‚ÄúZA7856_v1-0-0.dta‚Äù finden. Das ist der eigentliche Datensatz.\n\nDatensatz einlesen mit der Funktion read_dta(). Passen Sie den Pfad zur Datei an, da ich f√ºr die √úbung eine andere Verzeichnisstruktur habe!\n\n\ngesis <- read_dta('Daten/ZA7856_v1-0-0.dta/ZA7856_v1-0-0.dta')\n\n\nWie viele Beobachtungen und Variablen enth√§lt der Datensatz?\nDie Variablennamen sind nichtssagend. Um den Datensatz zu verstehen, laden Sie auf der GESIS-Seite das Codebook herunter (rechts oben bei Downloads). Die Variablennamen sind in der ‚ÄúTabelle 1: Variablenkorrespondenzliste Politbarometer 2021‚Äù gelistet.\nWir werden gemeinsam die Variablen richtig umbenennen und die kategorialen Variablen zu Faktoren √§ndern. Gehen Sie durch den Code Zeile f√ºr Zeile durch und erkl√§ren Sie, was dieser macht.\n\n\ngesis_short <- gesis %>% \n  rename(Befragtennummer = V2,\n         Erhebungsmonat = V4,\n         Erhebungswoche = V5,\n         Bundesland = V6,\n         Erhebungsgebiet = V7,\n         Einwohner = V8,\n         Polit_interesse = V124) %>%\n  mutate(Erhebungsmonat = as_factor(Erhebungsmonat),\n         Erhebungswoche = as_factor(Erhebungswoche),\n         Bundesland = as_factor(Bundesland),\n         Erhebungsgebiet = as_factor(Erhebungsgebiet),\n         Einwohner = as_factor(Einwohner),\n         Polit_interesse = as_factor(Polit_interesse)\n         ) %>% \n  select(Befragtennummer,\n         Erhebungsmonat,\n         Erhebungswoche,\n         Bundesland,\n         Erhebungsgebiet,\n         Einwohner,\n         Polit_interesse)\n\n\nWie hat sich der Typ der kategorialen Variablen im Datensatz gesis_short gegen√ºber dem urspr√ºnglichen Datensatz gesis ver√§ndert?\nSpeichern Sie den neuen Datensatz gesis_short mit write_delim() ab."
  },
  {
    "objectID": "100-aufgabensammlung.html#exploration-von-kategorialen-daten",
    "href": "100-aufgabensammlung.html#exploration-von-kategorialen-daten",
    "title": "Appendix A ‚Äî Aufgabensammlung",
    "section": "A.4 Exploration von kategorialen Daten",
    "text": "A.4 Exploration von kategorialen Daten\n\nA.4.1 Politbarometer 2021: Das Interesse f√ºr Politik\nWir analysieren den Datensatz, den Sie in der vorherigen √úbung geladen und vorbereitet haben.\n\nLaden Sie nun den kurzen Datensatz gesis_short mit der passenden Bibliothek ein. Sie m√ºssen vorher nat√ºrlich diese Bibliothek mit library() laden.\n\n\n\n\n\nUntersuchen Sie den Datensatz nach dem Laden. Wie sind die kategorialen Variablen kodiert (chr odr fct)? Warum? Sehen Sie in der Hilfe von read_delim nach.\nWir m√ºssen nach dem Einlesen die kategorialen Variablen erneut in Faktoren umwandeln. Diese Information geht durch das Speichern mit write_delim() und das erneute Einlesen mit read_delim() verloren. Wandeln Sie die Variable Bundesland in einen Faktor um. Wenn Sie mit der Funktion as_fcator() arbeiten, ist die Reihenfolge der Merkmalsauspr√§gungen (der unterschiedlichen Werte einer kategorialen Variablen) standardm√§√üig so, wie diese im Datensatz erscheinen. Das ist f√ºr die Bundesl√§nder ausreichend.\nWie viele Personen wurden pro Bundesland im Politbarometer im Jahr 2021 befragt?\nWir wollen nun wissen, wie das Politikinteresse in den Bundesl√§ndern ausgepr√§gt ist. Daf√ºr sehen wir uns die Antworten auf die Frage ‚ÄúWie stark interessieren Sie sich f√ºr Politik, ‚Ä¶‚Äù. Die Antworten sind in der Variablen Polit_Interesse enthalten. Wie haben die Befragten abgestimmt?\nDie Reihenfolge der Merkmalsauspr√§gungen ist unlogisch. Das m√ºssen wir √§ndern. Bei dieser Variablen gibt es eine logische Reihenfolge: Sehr stark, stark, etwas, kaum, gar nicht, KA. Letzteres steht f√ºr keine Angabe. Nutzen Sie den folgenden Code, um die Variable Polit_interesse in einen Faktor mit richtiger Reihenfolge der Merkmalsauspr√§gungen umzuwandeln.\n\n\ngesis_short <- gesis_short %>% \n  mutate(gesis_short <- gesis_short %>% \n  mutate(Polit_interesse = factor(Polit_interesse, levels = c('Sehr stark', 'stark', 'etwas', 'kaum', 'gar nicht', 'KA'))))\n\nWiederholen Sie nun die Aufgabe 5.\n\nVergleichen Sie die Antworten zwischen den Bundesl√§ndern. Ist das Interesse der B√ºrger √§hnlich? Warum ist das schwer zu beantworten?\nWir pirschen uns an die relativen H√§ufigkeiten heran. Was macht der nachfolgende Code. Sehen Sie gegebenenfalls in der Hilfe nach.\n\n\ngesis_short %>% \n  count(Bundesland, Polit_interesse) %>% \n  pivot_wider(names_from = Bundesland, values_from = n)\n\nDer n√§chste Schritt ist es, die relativen H√§ufigkeiten (Anteile) f√ºr jedes Bundesland auszurechnen, um die obige Frage zu beantworten. Erkl√§ren Sie, was der nachfolgende Code macht:\n\ngesis_short %>% \n  count(Bundesland, Polit_interesse) %>% \n  group_by(Bundesland) %>%\n  mutate(Anteil = n / sum(n)) %>% \n  select(-n) %>% \n  pivot_wider(names_from = Bundesland, values_from = Anteil)\n\nZur√ºck zu unserer Frage: Ist das Interesse der B√ºrger in allen Bundesl√§ndern √§hnlich?\n\nBeantworten Sie die Frage jetzt auch grafisch, indem Sie ein Balkendiagramm plotten. Es soll so aussehen:\n\n\n\n\n\n\nDaf√ºr k√∂nnen Sie folgende Code-Fragmente erg√§nzen:\n\nggplot(data = ___, mapping = aes(y = ___, fill = ___)) +\n  geom_bar(position = position_fill(reverse = TRUE)) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +\n  labs(___)\n\nWas macht geom_bar(position = position_fill(reverse = TRUE))?"
  },
  {
    "objectID": "30-lab-02-intro-to-data.html#erste-schritte",
    "href": "30-lab-02-intro-to-data.html#erste-schritte",
    "title": "9¬† Lab 02: P√ºnktlichkeit von Fl√ºgen",
    "section": "9.1 Erste Schritte",
    "text": "9.1 Erste Schritte\n\n9.1.1 Pakete laden\nIn dieser √úbung werden wir die Daten mithilfe der Paketsammlung tidyverse untersuchen und visualisieren. Die Daten befinden sich im Begleitpaket f√ºr OpenIntro-√úbungen, openintro.\nLassen Sie uns die Pakete laden.\n\nlibrary(tidyverse)\nlibrary(openintro)\n\n\n\n9.1.2 Erstellen eines reproduzierbaren Berichts\nDenken Sie daran, dass wir R Markdown verwenden werden, um reproduzierbare Berichte zu erstellen. Gehen Sie in RStudio zu New File -> R Markdown‚Ä¶ W√§hlen Sie dann From Template und w√§hlen Sie dann Lab Report for OpenIntro Statistics Labs aus der Liste der Vorlagen. Oder verfahren Sie so, wie wir es in den √úbungen gelernt haben New File -> R Notebook‚Ä¶ Beide Varianten sind in Ordnung. Wenn Sie die Variante mit R Markdown w√§hlen, gibt es keinen Button ‚ÄúPreview‚Äù, sondern Sie m√ºssen das Dokument ‚Äúknitten‚Äù √ºber den Button mit dem Wollkn√§uel.\nSehen Sie sich das folgende Video an, in dem beschrieben wird, wie Sie mit der Erstellung dieser Berichte f√ºr dieses und alle zuk√ºnftigen Labs beginnen k√∂nnen:\nGrundlegendes zu R Markdown mit einer OpenIntro-√úbung \n\n\n9.1.3 Die Daten\nDas Bureau of Transportation Statistics (BTS) ist eine Statistikbeh√∂rde, die zur Research and Innovative Technology Administration (RITA) geh√∂rt. Wie der Name schon sagt, sammelt das BTS Verkehrsdaten und stellt sie zur Verf√ºgung, wie z. B. die Flugdaten, mit denen wir in diesem Labor arbeiten werden.\nAls Erstes werden wir uns den Datensatz nycflights ansehen. Geben Sie Folgendes in Ihre Konsole ein, um die Daten zu laden:\n\ndata(nycflights)\n\nDer Datensatz nycflights, der in Ihrem Arbeitsbereich angezeigt wird, ist eine Datenmatrix oder Datentabelle, wobei jede Zeile eine Beobachtung und jede Spalte eine Variable darstellt. In R wird dieses Datenformat als Dataframe bezeichnet, ein Begriff, der in den √úbungen immer wieder verwendet wird. Bei diesem Datensatz ist jede Beobachtung ein einzelner Flug.\nUm die Namen der Variablen anzuzeigen, geben Sie den Befehl\n\nnames(nycflights)\n\nDies gibt die Namen der Variablen in diesem Datenrahmen zur√ºck. Das Codebuch (Beschreibung der Variablen) kann √ºber die Hilfedatei abgerufen werden:\n\n?nycflights\n\nEine der Variablen bezieht sich auf die Fluggesellschaft des Fluges, die nach folgendem System kodiert wird.\n\ncarrier (Fluggesellschaft): Zweibuchstabiges K√ºrzel der Fluggesellschaft.\n\n9E: Endeavor Air Inc.\nAA: American Airlines Inc.\nAS: Alaska Airlines Inc.\nB6: JetBlue Airways\nDL: Delta Air Lines Inc.\nEV: ExpressJet Fluggesellschaften Inc.\nF9: Frontier Airlines Inc.\nFL: AirTran Airways Corporation\nHA: Hawaiian Airlines Inc.\nMQ: Envoy Air\nOO: SkyWest Airlines Inc.\nUA: United Air Lines Inc.\nUS: US Airways Inc.\nVX: Virgin America\nWN: Southwest Airlines Co.\nYV: Mesa Airlines Inc.\n\n\nDenken Sie daran, dass Sie die Funktion glipmse() nutzen k√∂nnen, um einen √úberblick √ºber die Daten zu erhalten und somit deren Inhalt besser zu verstehen.\n\nglimpse(nycflights)\n\nDer Datensatz nycflights ist eine riesige Fundgrube an Informationen. Lassen Sie uns √ºber einige Fragen nachdenken, die wir mit diesen Daten beantworten wollen:\n\nWie versp√§tet waren die Fl√ºge nach Los Angeles?\nWie unterscheiden sich die Abflugversp√§tungen je nach Monat?\nWelcher der drei gro√üen Flugh√§fen in New York hat den besten Prozentsatz an p√ºnktlichen Abfl√ºgen?"
  },
  {
    "objectID": "30-lab-02-intro-to-data.html#analyse",
    "href": "30-lab-02-intro-to-data.html#analyse",
    "title": "9¬† Lab 02: P√ºnktlichkeit von Fl√ºgen",
    "section": "9.2 Analyse",
    "text": "9.2 Analyse\n\n9.2.1 Bericht\nUm Ihre Analyse in einem reproduzierbaren Bericht festzuhalten, k√∂nnen Sie die allgemeine Vorlage f√ºr Berichte aus dem Paket openintro anpassen. Sehen Sie sich das Video oben an, um zu erfahren, wie das geht.\n\n\n9.2.2 Abflugversp√§tungen\nBeginnen wir damit, die Verteilung der Abflugversp√§tungen aller Fl√ºge mit einem Histogramm zu untersuchen.\n\nggplot(data = nycflights, aes(x = dep_delay)) +\n  geom_histogram()\n\nMit dieser Funktion wird die Variable dep_delay aus dem Dataframe nycflights auf der \\(x\\)-Achse dargestellt. Sie definiert auch ein geom (kurz f√ºr geometrisches Objekt), das die Art der Darstellung beschreibt, die Sie erzeugen werden.\nHistogramme eignen sich im Allgemeinen sehr gut, um die Form der Verteilung einer einzelnen numerischen Variablen zu sehen, aber diese Form kann sich √§ndern, je nachdem, wie die Daten auf die verschiedenen Bins aufgeteilt sind. Sie k√∂nnen die zu verwendende Bin-Breite einfach festlegen:\n\nggplot(data = nycflights, aes(x = dep_delay)) +\n  geom_histogram(binwidth = 15)\n\n\nggplot(data = nycflights, aes(x = dep_delay)) +\n  geom_histogram(binwidth = 150)\n\n\n\nSchauen Sie sich diese drei Histogramme genau an. Wie lassen sie sich vergleichen? Sind in einem Histogramm Merkmale zu erkennen, die in einem anderen verdeckt sind?\n\n\nWenn Sie nur die Versp√§tungen von Fl√ºgen nach Los Angeles anzeigen m√∂chten, m√ºssen Sie zun√§chst die Daten nach Fl√ºgen mit diesem Ziel filter()n (dest == \"LAX\") und dann ein Histogramm der Abflugversp√§tungen nur dieser Fl√ºge erstellen.\n\nlax_flights <- nycflights %>%\n  filter(dest == \"LAX\")\nggplot(data = lax_flights, aes(x = dep_delay)) +\n  geom_histogram()\n\nLassen Sie uns diese beiden Befehle entschl√ºsseln (OK, es sieht vielleicht nach vier Zeilen aus, aber die ersten beiden physischen Codezeilen sind tats√§chlich Teil desselben Befehls. Es ist √ºblich, nach %>% einen Zeilenumbruch einzuf√ºgen, um die Lesbarkeit zu verbessern).\n\nBefehl 1: Nehmen Sie den Dataframe nycflights, filter()n Sie nach Fl√ºgen zum LAX und speichern Sie das Ergebnis als neuen Datenrahmen namens lax_flights.\n\n== bedeutet ‚Äúwenn es gleich ist mit‚Äù.\nLAX steht in Anf√ºhrungszeichen, da es sich um eine Zeichenkette handelt.\n\nBefehl 2: Im Grunde derselbe ggplot-Aufruf wie bei der Erstellung eines Histogramms, nur dass hier das kleinere Dataframe f√ºr Fl√ºge mit Ziel LAX anstelle aller Fl√ºge verwendet wird.\n\n\nLogische Operatoren: Das Filtern nach bestimmten Beobachtungen (z. B. Fl√ºge von einem bestimmten Flughafen) ist in Dataframes oft von Interesse, wenn wir Beobachtungen mit bestimmten Merkmalsauspr√§gungen getrennt vom Rest der Daten untersuchen m√∂chten. Zu diesem Zweck k√∂nnen Sie die Filterfunktion und eine Reihe von logischen Operatoren verwenden. Die am h√§ufigsten verwendeten logischen Operatoren f√ºr die Datenanalyse sind die folgenden:\n\n== bedeutet ‚Äúgleich‚Äù\n!= bedeutet ‚Äúnicht gleich‚Äù\n> oder < bedeutet ‚Äúgr√∂√üer als‚Äù oder ‚Äúkleiner als‚Äù.\n>= oder <= bedeutet ‚Äúgr√∂√üer als oder gleich‚Äù oder ‚Äúkleiner als oder gleich‚Äù.\n\n\nSie k√∂nnen auch numerische Zusammenfassungen f√ºr diese Fl√ºge erhalten:\n\nlax_flights %>%\n  summarise(mean_dd   = mean(dep_delay), \n            median_dd = median(dep_delay), \n            n         = n())\n\nBeachten Sie, dass Sie in der Funktion summarise() eine Liste mit drei verschiedenen numerischen Zusammenfassungen erstellt haben, an denen Sie interessiert waren. Die Namen dieser Elemente sind benutzerdefiniert, wie mean_dd, median_dd, n, und Sie k√∂nnen diese Namen nach Belieben anpassen (verwenden Sie nur keine Leerzeichen in Ihren Namen). F√ºr die Berechnung dieser zusammenfassenden Statistiken m√ºssen Sie auch die Funktionsaufrufe kennen. Beachten Sie, dass n() den Stichprobenumfang angibt.\n\nZusammenfassende Statistiken aka statistische Lage- und Streuma√üe: Einige n√ºtzliche Funktionsaufrufe f√ºr zusammenfassende Statistiken f√ºr eine einzelne numerische Variable sind wie folgt:\n\nMittelwert: mean()\nMedian: median()\nStandardabweichung: sd()\nVarianz: var()\nInterquartilabstand: IQR()\nKleinster Wert: min()\nGr√∂√üter Wert: max()\n\nBeachten Sie, dass jede dieser Funktionen einen einzelnen Vektor als Argument annimmt und einen einzelnen Wert zur√ºckgibt.\n\nSie k√∂nnen auch nach mehreren Kriterien filtern. Angenommen, Sie sind an Fl√ºgen nach San Francisco (SFO) im Februar interessiert:\n\nsfo_feb_flights <- nycflights %>%\n  filter(dest == \"SFO\", month == 2)\n\nBeachten Sie, dass Sie die Bedingungen durch Kommas trennen k√∂nnen, wenn Sie Fl√ºge sowohl nach SFO als auch im Februar suchen. Wenn Sie entweder an Fl√ºgen nach SFO oder an Fl√ºgen im Februar interessiert sind, k√∂nnen Sie das | anstelle des Kommas verwenden.\n\n\nErstellen Sie ein neues Dataframe, das Fl√ºge nach SFO im Februar enth√§lt, und speichern Sie diesen Datenrahmen als sfo_feb_flights. Wie viele Fl√ºge erf√ºllen diese Kriterien?\nBeschreiben Sie die Verteilung der Ankunftsversp√§tungen arr_delay dieser Fl√ºge anhand eines Histogramms und geeigneter zusammenfassender Statistiken. Tipp: Die von Ihnen verwendete zusammenfassende Statistik sollte von der Form der Verteilung abh√§ngen.\n\n\nEine weitere n√ºtzliche Methode ist die schnelle Berechnung von zusammenfassenden Statistiken f√ºr verschiedene Gruppen in Ihrem Dataframe. Wir k√∂nnen den obigen Befehl etwa mit der Funktion group_by() modifizieren, um die gleiche zusammenfassende Statistik f√ºr jeden Herkunftsflughafen zu erhalten:\n\nsfo_feb_flights %>%\n  group_by(origin) %>%\n  summarise(median_dd = median(dep_delay), iqr_dd = IQR(dep_delay), n_flights = n())\n\nHier haben wir die Daten zun√§chst nach Herkunft gruppiert und dann die zusammenfassenden Statistiken berechnet.\n\n\nBerechnen Sie den Median und den Interquartilsabstand f√ºr arr_delays der Fl√ºge im Datenrahmen sfo_feb_flights, gruppiert nach Fluggesellschaft. Welche Fluggesellschaft hat Ankunftsversp√§tungen mit der gr√∂√üten Variabilit√§t?"
  },
  {
    "objectID": "30-lab-02-intro-to-data.html#abflugversp√§tungen-nach-monaten",
    "href": "30-lab-02-intro-to-data.html#abflugversp√§tungen-nach-monaten",
    "title": "9¬† Lab 02: P√ºnktlichkeit von Fl√ºgen",
    "section": "9.3 Abflugversp√§tungen nach Monaten",
    "text": "9.3 Abflugversp√§tungen nach Monaten\nIn welchem Monat w√ºrden Sie die h√∂chste durchschnittliche Versp√§tung bei Abfl√ºgen von einem New Yorker Flughafen erwarten?\nLassen Sie uns √ºberlegen, wie Sie diese Frage beantworten k√∂nnen:\n\nBerechnen Sie zun√§chst die monatlichen Durchschnittswerte f√ºr Abflugversp√§tungen. Mit der neuen Sprache, die Sie gerade lernen, k√∂nnten Sie\n\ngroup_by() nach Monaten, dann\ndie durchschnittlichen Abflugversp√§tungen zusammenfassen mit summarise().\n\nDann k√∂nnten Sie diese durchschnittlichen Versp√§tungen in absteigender Reihenfolge mit arrange()anordnen\n\n\nnycflights %>%\n  group_by(month) %>%\n  summarise(mean_dd = mean(dep_delay)) %>%\n  arrange(desc(mean_dd))\n\n\n\nAngenommen, Sie m√∂gen keine Versp√§tungen bei der Abreise und m√∂chten Ihre Reise in einem Monat planen, der Ihre m√∂gliche Versp√§tung bei der Abreise aus New York minimiert. Eine M√∂glichkeit ist, den Monat mit dem geringsten Mittelwerten der Abflugversp√§tung zu w√§hlen. Eine andere M√∂glichkeit ist, den Monat mit dem geringsten Median der Abflugversp√§tung zu w√§hlen. Was sind die Vor- und Nachteile dieser beiden M√∂glichkeiten?\n\n\n\n9.3.1 P√ºnktliche Abflugrate f√ºr NYC-Flugh√§fen\nAngenommen, Sie fliegen von New York City aus und m√∂chten wissen, welcher der drei gro√üen Flugh√§fen in New York City die beste P√ºnktlichkeitsrate bei abgehenden Fl√ºgen aufweist. Nehmen wir weiter an, dass f√ºr Sie ein Flug, der weniger als 5 Minuten Versp√§tung hat, grunds√§tzlich ‚Äúp√ºnktlich‚Äù (‚Äúon time‚Äù) ist. Sie betrachten jeden Flug, der mehr als 5 Minuten Versp√§tung hat, als ‚Äúversp√§tet‚Äù (‚Äúdelayed‚Äù).\nUm festzustellen, welcher Flughafen die beste P√ºnktlichkeitsquote hat, k√∂nnen Sie\n\nzun√§chst jeden Flug als ‚Äúon time‚Äù oder ‚Äúdelayed‚Äù einstufen,\ndann die Fl√ºge nach Herkunftsflughafen gruppieren,\ndann die Rate der p√ºnktlichen Abfl√ºge f√ºr jeden Herkunftsflughafen berechnen,\nund schlie√ülich die Flugh√§fen in absteigender Reihenfolge nach dem Prozentsatz der p√ºnktlichen Abfl√ºge ordnen.\n\nBeginnen wir mit der Klassifizierung der einzelnen Fl√ºge als ‚Äúon time‚Äù oder ‚Äúdelayed‚Äù, indem wir mit der Funktion mutate() eine neue Variable erstellen.\n\nnycflights <- nycflights %>%\n  mutate(dep_type = ifelse(dep_delay < 5, \"on time\", \"delayed\"))\n\nDas erste Argument in der Funktion mutate() ist der Name der neuen Variable, die wir erstellen wollen, in diesem Fall dep_type. Wenn dep_delay < 5 ist, klassifizieren wir den Flug als ‚Äúon time‚Äù, wenn nicht, als ‚Äúdelayed‚Äù, d.¬†h. wenn der Flug 5 oder mehr Minuten versp√§tet ist.\nBeachten Sie, dass wir auch das Dataframe nycflights mit der neuen Version dieses Dataframes √ºberschreiben, der die neue Variable dep_type enth√§lt.\nAlle √ºbrigen Schritte k√∂nnen wir in einem einzigen Code-Chunk erledigen:\n\nnycflights %>%\n  group_by(origin) %>%\n  summarise(ot_dep_rate = sum(dep_type == \"on time\") / n()) %>%\n  arrange(desc(ot_dep_rate))\n\n\n\nWenn Sie einen Flughafen nur aufgrund des prozentualen Anteils der Abfl√ºge in der Zeit ausw√§hlen w√ºrden, welchen Flughafen in NYC w√ºrden Sie dann w√§hlen?\n\n\nSie k√∂nnen auch die Verteilung der p√ºnktlichen Abflugrate auf die drei Flugh√§fen mithilfe eines Balkendiagramms visualisieren.\n\nggplot(data = nycflights, aes(x = origin, fill = dep_type)) +\n  geom_bar()"
  },
  {
    "objectID": "30-lab-02-intro-to-data.html#weitere-√ºbungen",
    "href": "30-lab-02-intro-to-data.html#weitere-√ºbungen",
    "title": "9¬† Lab 02: P√ºnktlichkeit von Fl√ºgen",
    "section": "9.4 Weitere √úbungen",
    "text": "9.4 Weitere √úbungen\n\n\n√Ñndern Sie das Dataframe so, dass es eine neue Variable enth√§lt, die die Durchschnittsgeschwindigkeit, avg_speed, die das Flugzeug bei jedem Flug zur√ºckgelegt hat (in mph), angibt. Tipp: Die Durchschnittsgeschwindigkeit kann als Entfernung geteilt durch die Anzahl der Flugstunden berechnet werden, und beachten Sie, dass die Flugzeit air_time in Minuten angegeben wird.\nErstellen Sie ein Streudiagramm von der Durchschnittsgeschwindigkeit avg_speed und Entfernung distance. Beschreiben Sie die Beziehung zwischen Durchschnittsgeschwindigkeit und Entfernung. Tipp: Verwenden Sie geom_point().\nBauen Sie die folgende Darstellung nach. Tipp: Das dargestellte Dataframe enth√§lt nur Fl√ºge von American Airlines, Delta Airlines und United Airlines, und die Punkte sind nach Fluggesellschaft carrier eingef√§rbt (colored). Ermitteln Sie nach dem Plotten (grob) den Grenzwert f√ºr Abflugversp√§tungen, bei dem Sie noch erwarten k√∂nnen, Ihr Ziel rechtzeitig zu erreichen."
  },
  {
    "objectID": "06-explorative-numerisch.html",
    "href": "06-explorative-numerisch.html",
    "title": "6¬† Exploration von numerischen Daten",
    "section": "",
    "text": "Kernpakete aus tidyverse benennen\nein Workflow (Daten einlesen, zusammenfassen, darstellen) mit tidyverse durchf√ºhren\nFunktionen des Pakets dplyr f√ºr Datentransformation anwenden\ntidyverse ist eine Sammlung von R-Paketen, die explizit f√ºr Datenanalyse entwickelt wurden (https://www.tidyverse.org/). tidyverse versucht durch gemeinsame Philosophie in Design, Grammatik und Datenstruktur die Datenanalyse zu erleichtern (https://design.tidyverse.org/). Auch wenn tidyverse auf den ersten Blick etwas fremd erscheint, es ist ein Teil von R, kein eigenes Universum. Es ist also v√∂llig in Ordnung, R-Basisfunktionen mit Funktionen aus tidyverse zu mischen.\nDas wichtigste Einf√ºhrungsbuch zu tidyverse ist sicherlich R4DS: ‚ÄúR for Data Science‚Äù (Wickham and Grolemund 2021), das Sie kostenlos online lesen k√∂nnen (https://r4ds.had.co.nz/)."
  },
  {
    "objectID": "06-explorative-numerisch.html#grundpakete",
    "href": "06-explorative-numerisch.html#grundpakete",
    "title": "6¬† Exploration von numerischen Daten",
    "section": "6.1 Grundpakete",
    "text": "6.1 Grundpakete\ntidyverse enth√§lt folgende Grundpakete, die alle installiert werden, wenn Sie install.packages('tidyverse') ausf√ºhren.\n\n\n\nPaketname\nKurzbeschreibung\n\n\n\n\nggplot2\nVisualisierung\n\n\ndplyr\nDatentransformation\n\n\ntidyr\nDatenbereinigung\n\n\nreadr\nDaten einlesen\n\n\npurrr\nFunktionale Programmierung (Funktionen auf Objekte anwenden)\n\n\ntibble\nErweiterung von data.frame\n\n\nstringr\nFunktionen f√ºr Strings, d.¬†h. Textvariablen\n\n\nforcats\nFunktionen f√ºr factor\n\n\n\nJedes dieser Pakete hat ein Cheat Sheet, eine √ºbersichtliche Zusammenstellung der Funktionen des Pakets. Sie bekommen die Cheet Sheats √ºber die tidyverse-Seite (https://www.tidyverse.org/packages/), indem Sie auf das jeweilige Paket klicken und zum Abschnitt ‚ÄòCheatsheet‚Äô scrollen."
  },
  {
    "objectID": "06-explorative-numerisch.html#der-explorative-workflow",
    "href": "06-explorative-numerisch.html#der-explorative-workflow",
    "title": "6¬† Exploration von numerischen Daten",
    "section": "6.2 Der explorative Workflow",
    "text": "6.2 Der explorative Workflow\n\n6.2.1 Daten einlesen, revisited\nAls Erstes laden wir die Bibliothek tidyverse.\n\nlibrary(tidyverse)\n\nSie kennen bereits die Funktion read_delim() zum Einlesen von Textdateien. Die Funktion ist die allgemeinste Funktion der read_* Familie aus readr in tidyverse; read_csv() und read_csv2() sind jeweils f√ºr komma- und strichpunkt-getrennte Datens√§tze gedacht. In der Basisinstallation von R (also au√üerhalb von tidyverse) gibt die sehr umfangreiche Funktion read.table(), die ebenfalls zum Einlesen von Textdateien verwendet wird. Man k√∂nnte berechtigterweise fragen, warum neue Funktion (read_*) f√ºr etwas erfinden, was es schon gibt. Die Autoren von tidyverse versprechen Konsistenz und Geschwindigkeit. Ersteres war schon immer ein Problem von R, da es nicht von Computerspezialisten, sondern von Anwendern erfunden wurde. Daher ist eine Vereinheitlichung durch tidyverse mehr als willkommen. Und Geschwindigkeit ist sp√§testens bei gr√∂√üeren Datens√§tzen ein wichtiger Punkt.\nWir sehen uns Daten des Deutschen Wetterdienstes an, die ich am 24. Mai 2020 heruntergeladen habe (https://www.dwd.de/DE/leistungen/klimadatendeutschland/klimadatendeutschland.html). Der Datensatz enth√§lt Stundenwerte f√ºr relative Luftfeuchte (%) und Lufttemperatur (¬∞C) von drei Wetterstationen, n√§mlich Hof, Frankfurt und K√∂ln-Bonn. Die Daten sind in der Datei ‚ÄúDrei_Stationen.csv‚Äù gespeichert.\nBeim Einlesen zeigt Ihnen read_delim() bereits, welche Spalten und welche Datentypen es erkennt, mit trim_ws = T werden Leerzeichen aus Spalten entfernt, weil die Daten sonst falsch eingelesen werden.\n\ntemp_humid <- read_delim('Daten/Drei_Stationen.csv', delim = ';', trim_ws = T)\n\nRows: 39600 Columns: 6\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \";\"\nchr (1): eor\ndbl (5): STATIONS_ID, MESS_DATUM, QN_9, TT_TU, RF_TU\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nEs sollte f√ºr Sie bereits Routine sein, das Ergebnis des Einlesens zu kontrollieren.\n\ntemp_humid\n\n\n\n  \n\n\n\nAlternative k√∂nnen Sie die Funktion glimpse() verwenden.\n\nglimpse(temp_humid)\n\nRows: 39,600\nColumns: 6\n$ STATIONS_ID <dbl> 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261‚Ä¶\n$ MESS_DATUM  <dbl> 2018111900, 2018111901, 2018111902, 2018111903, 2018111904‚Ä¶\n$ QN_9        <dbl> 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3‚Ä¶\n$ TT_TU       <dbl> -2.8, -2.5, -2.3, -2.0, -1.9, -2.1, -1.8, -1.5, -1.1, -0.6‚Ä¶\n$ RF_TU       <dbl> 99, 100, 100, 100, 99, 99, 99, 99, 99, 97, 95, 93, 94, 88,‚Ä¶\n$ eor         <chr> \"eor\", \"eor\", \"eor\", \"eor\", \"eor\", \"eor\", \"eor\", \"eor\", \"e‚Ä¶\n\n\nIn diesem Datensatz sind folgende Variablen (Spalten) enthalten (s. Datensatzbeschreibung des DWDs)\n\n\n\nVariablen\nBeschreibung\n\n\n\n\nSTATIONS_ID\nStationsidentifikationsnummer\n\n\nMESS_DATUM\nZeitstempel im Format yyyymmddhh\n\n\nQN_9\nQualit√§tsniveau der nachfolgenden Spalten\n\n\nTT_TU\nLufttemperatur in 2 m H√∂he ¬∞C\n\n\nRF_TU\nrelative Feuchte %\n\n\neor\nEnde data record"
  },
  {
    "objectID": "06-explorative-numerisch.html#geschickter-umgang-mit-zeit-und-datum",
    "href": "06-explorative-numerisch.html#geschickter-umgang-mit-zeit-und-datum",
    "title": "6¬† Exploration von numerischen Daten",
    "section": "6.3 Geschickter Umgang mit Zeit und Datum",
    "text": "6.3 Geschickter Umgang mit Zeit und Datum\nEin weiteres Paket, das zwar nicht zum Kern von tidyverse geh√∂rt, jedoch trotzdem extrem n√ºtzlich ist, hei√üt lubridate. Das haben wir bereits im letzten Kapitel verwendet, um aus einem Datum das Jahr zu extrahieren. lubridate hilft aber auch, Text sehr einfach in richtige Datums-Objekte zu transformieren. Wir transformieren die Spalte temp_humid$MESS_DATUM in ein richtiges Datum mit Uhrzeit. Die Funktion ymd_h() kann character in ein richtiges Datumsformat transformieren, wenn das Datum als year, month, day, hour codiert ist. Es gibt noch weitere Varianten der Codierung, die Sie bei Bedarf in der Hilfe nachschlagen sollten.\n\nlibrary(lubridate)\n\ntemp_humid$MESS_DATUM <- ymd_h(temp_humid$MESS_DATUM)\n\ntemp_humid\n\n\n\n  \n\n\n\n\n6.3.1 Daten zusammenfassen\nDie drei Wetterstationen haben folgende IDs:\n\nstation_ids <-  c('2261' = 'Hof', '1420' = 'Frankfurt', '2667' = 'Koeln')\n\nWir z√§hlen nach, wie viele Messpunkte es pro Station gibt. Die Funktion count() kennen Sie bereits. Sie z√§hlt, wie h√§ufig unterschiedlichen Merkmalsauspr√§gungen vorkommen:\n\ntemp_humid %>% \n  count(STATIONS_ID)\n\n\n\n  \n\n\n\nDie Zeichenkombination %>% hei√üt Pipe-Operator (pipe) und wird als ‚Äòund dann‚Äô gelesen (then). Diesen Operator haben wir bereits im letzten Kapitel verwendet. Der Ausdruck temp_humid %>% count(STATIONS_ID) hei√üt also: nimm das Objekt temp_humid, und z√§hle dann die Anzahl der verschiedenen Merkmalsauspr√§gungen zusammen. Der Pipe-Operator ist die Kernphilosophie von tidyverse und wird Ihnen √ºberall begegnen. Der Operator stammt aus dem Paket magrittr (https://magrittr.tidyverse.org/). Seine Hauptaufgabe ist es, den Code √ºbersichtlicher und besser lesbar zu machen (vielleicht nicht gleich zu Beginn der Lernkurve, aber schon bald üòé)."
  },
  {
    "objectID": "06-explorative-numerisch.html#die-grammatik-der-datenmanipulation-dplyr",
    "href": "06-explorative-numerisch.html#die-grammatik-der-datenmanipulation-dplyr",
    "title": "6¬† Exploration von numerischen Daten",
    "section": "6.4 Die Grammatik der Datenmanipulation ‚Äì dplyr",
    "text": "6.4 Die Grammatik der Datenmanipulation ‚Äì dplyr\nDie Funktion count() geh√∂rt zum Paket dplyr, das f√ºr Datentransformationen zust√§ndig ist. Es ist mal wieder eine Grammatik. Dieses Paket enth√§lt 5 Grundfunktionen (alle nach Verben benannt, damit man gleich wei√ü, was frau tut üòÑ):\n\n\n\n\n\n\n\nFunktion\nBedeutung\n\n\n\n\nfilter()\nW√§hle Daten anhand ihrer Werte\n\n\narrange()\nSortiere Zeilen\n\n\nselect()\nW√§hle Variablen anhand ihrer Namen\n\n\nmutate()\nErstelle neue Variablen als Funktionen vorhandener Variablen\n\n\nsummarize()\nFasse Daten zusammen\n\n\n\nWenn wir nur von einer bestimmten Station die Anzahl der Messwerte wissen m√∂chten, dann filtern wir vorher.\n\ntemp_humid %>% \n  filter(STATIONS_ID == '2667') %>%\n  count(STATIONS_ID)\n\n\n\n  \n\n\n\nBeim Filtern l√§uft eine logische Abfrage. D. h. es wird bei jeden Eintrag in STATION_ID nachgesehen, ob da der Wert 2667 steht. Wenn da 2667 steht, dann gibt == ein TRUE zur√ºck, wenn da etwas anderes steht, dann gibt == ein FALSE zur√ºck. Und die Funktion filter() beh√§lt nur die Zeilen, bei denen == ein TRUE zur√ºckgegeben hat.\nWeiter wichtige logische und relationale Operatoren finden Sie hier in der Hilfe zu filter(). Hier ein paar einfache Beispiele\n\n\n\n\n\n\n\nOperator\nBedeutung\n\n\n\n\n==/ > / >=\nist die linke Seite gleich / gr√∂√üer / gr√∂√üer-gleich als die rechte Seite\n\n\n!=\nist die linke Seite ungleich der rechten Seite\n\n\n\nZudem kann man bei filter() die Anfragen auch kombinieren. Wir wollen z. B. die Stationen K√∂ln und Hof haben. | ist der logische Operator oder. Wenn man also sowohl K√∂ln als auch Hof haben will, sagt man: finde alles, was entweder gleich K√∂ln oder gleich Hof ist.\n\ntemp_humid %>% \n  filter(STATIONS_ID == '2667' | STATIONS_ID == '2261') %>%\n  count(STATIONS_ID)\n\n\n\n  \n\n\n\nDas Gleiche erreicht man mit folgendem Code, indem man Frankfurt ausschlie√üt:\n\ntemp_humid %>% \n  filter(STATIONS_ID != '1420') %>%\n  count(STATIONS_ID)\n\n\n\n  \n\n\n\nAlternative kann man auch den Operator %in% verwenden. Dieser ist sehr n√ºtzlich, wenn man anhand einer einzelnen Variablen filtert, aber unterschiedliche Eintr√§ge ausw√§hlen m√∂chte (z. B. zwei Messstationen). Es wird bei jeder Zeile in der Variablen STATIONS_ID nun √ºberpr√ºft, ob hier entweder 2667 oder 2261 stehen.\n\ntemp_humid %>% \n  filter(STATIONS_ID %in% c('2667', '2261')) %>%\n  count(STATIONS_ID)\n\n\n\n  \n\n\n\n\n6.4.1 Daten plotten\nWir sehen uns die Daten erst mal an, bevor wir weiter machen. Wir plotten die Temperatur. Weil es sich um Zeitreihen handelt, kommt auf die \\(x\\)-Achse die Zeit.\n\nggplot(data = temp_humid, aes(x = MESS_DATUM, y = TT_TU, color = as_factor(STATIONS_ID))) + \n  geom_line() +\n  labs(x = 'Zeit', y = 'Temperatur (¬∞C)', color = 'Stationen')\n\n\n\n\nBeachten Sie, dass wir die Variable zum Einf√§rben, n√§mlichSTATIONS_ID, direkt in ggplot() in eine kategoriale Variable umgewandelt haben. Sonst werden die Farben als Farbeverlauf statt drei unterschiedliche Farben, dargestellt.\nDa man erwarten kann, dass sich der Temperaturverlauf innerhalb Deutschlands nicht so stark unterscheidet, √ºberdecken sich die Zeitreihen. Das ist f√ºr die Darstellung ung√ºnstig. Daher w√§re es besser, wenn wir die Zeitreihen in getrennte Grafiken je Station plotten w√ºrden. Daf√ºr gibt es eine neue Funktion aus dem Paket ggplot2, n√§mlich facet_wrap(). Sie kann eine Grafik mithilfe einer kategorialen Variablen in Teilgrafiken aufteilen.\n\nggplot(data = temp_humid, aes(x = MESS_DATUM, y = TT_TU)) + \n  geom_line() +\n  facet_wrap(~STATIONS_ID, nrow = 3) +\n  labs(x = 'Zeit', y = 'Temperatur (¬∞C)')\n\n\n\n\nDa wir die Teilgrafiken untereinander darstellen m√∂chten, setzen wir bei facet_wrap() den Parameter nrow = 3. Bei Teilgrafiken kann man auf die F√§rbung der Zeitreihen verzichten.\n\n\n6.4.2 Jahresdurchschnittstemperatur\nWie hoch war die Jahresdurchschnittstemperatur auf den drei Stationen? Um diese Frage zu beantworten, erstellen wir zun√§chst eine neue Variable mit dem Jahr der Messungen. Das kennen Sie bereits aus dem letzten Kapitel. Die Funktion year() geh√∂rt zur Bibliothek lubridate. Die Funktion mutate() erstellt die neue Spalte und h√§ngt sie an das Ende des Dataframes.\n\ntemp_humid <- temp_humid %>% \n  mutate(year = year(MESS_DATUM))\n\nDa wir die Durchschnittstemperatur f√ºr jede Station und jedes Jahr separat berechnen wollen, m√ºssen wir unseren Datensatz nach den Stationen gruppieren. Durch die Gruppierung entstehen intern Gruppen, f√ºr die Berechnungen getrennt laufen werden. An den Daten selbst √§ndert sich nichts.\nAls zweiten Schritt nutzen wir dann die Funktion summerise(), die verschiedene statistische Zusammenfassungen der Daten berechnen kann. In diesem Fall m√∂chten wir mithilfe der Funktion mean() den Mittelwert berechnen. Wir nennen den neu berechneten Datensatz yearly_means.\n\nyearly_means <- temp_humid %>%\n  group_by(STATIONS_ID, year) %>% \n  summarize(mean_T = mean(TT_TU))\n\n`summarise()` has grouped output by 'STATIONS_ID'. You can override using the\n`.groups` argument.\n\n\nWir erhalten einen Datensatz, der pro Jahr und Station einen Mittelwert der Temperatur enth√§lt. Die Variable, die die mittlere Temperatur enth√§lt, haben wir mean_T genannt. Sie steht in der Zeile summarize(mean_T = mean(TT_TU)) links vom Aufruf der Funktion mean(). Der Code mean(TT_TU) berechnet den Mittelwert der Variablen TT_TU, also der Temperatur.\n\nyearly_means\n\n\n\n  \n\n\n\nDie Berechnung der Jahresmittelwerte ist sehr kritisch zu sehen. Nicht alle berechneten Werte machen Sinn. Diskutieren Sie in der Hausaufgabe warum.\n\n\n6.4.3 Monatliche Durchschnittstemperatur und ihre Variabilit√§t\nWie hoch war die monatliche Durchschnittstemperatur auf den verschiedenen Stationen und wie stark schwankte sie? Diese Frage k√∂nnen wir beantworten, indem wir Mittelwerte und Standardabweichungen f√ºr jeden Monat eines jeden Jahres und jede Station berechnen. F√ºr die Berechnung erstellen wir eine weite Spalte mit dem Monat. Die Funktion month() geh√∂rt ebenfalls zur Bibliothek lubridate und extrahiert den Monat aus MESS_DATUM.\n\ntemp_humid <- temp_humid %>% \n  mutate(month = month(MESS_DATUM))\n\ntemp_humid\n\n\n\n  \n\n\n\nJetzt k√∂nnen wir die Mittelwerte und die Standardabweichungen mit der Funktion summarise() berechnen. Diese Funktion kann gleichzeitig verschiedene statistische Zusammenfassungen berechnen. Den Mittelwert berechnen wir erneut mit der Funktion mean() und die Standardabweichung mit der Funktion sd().\nF√ºr die Berechnung gruppieren wir die Daten nach STATIONS_ID, year und month mit der Funktion group_by(). Die Mittelwerte sollen ja je Station, Jahr und Monat berechnet werden. Beim Gruppieren gibt man die Variablennamen ohne Anf√ºhrungszeichen durch Kommas getrennt an. Man kann nach einer oder mehreren Variablen gruppieren, die Logik bleibt immer die gleiche, n√§mlich group_by(VARIABLE_1) f√ºrs Gruppieren mit einer Variablen oder group_by(VARIABLE_1, VARIABLE_2, VARIABLE_3) f√ºr z. B. gruppieren nach drei Variablen.\n\nmonthly_means <- temp_humid %>%\n  group_by(STATIONS_ID, year, month) %>% \n  summarize(mean_T = mean(TT_TU), sd_T = sd(TT_TU))\n\n`summarise()` has grouped output by 'STATIONS_ID', 'year'. You can override\nusing the `.groups` argument.\n\nmonthly_means\n\n\n\n  \n\n\n\nDie Variable, die die Standardabweichung enth√§lt, haben wir sd_T genannt.\nDas Dataframe monthly_means ist ein gruppiertes tibble. Das ist f√ºr die meisten Anwendungen nicht von Belang. Insbesondere √§ndert es nicht die Daten selbst, sondern nur die interne Organisation des tibble. Manchmal st√∂rt die Gruppierung jedoch beim Rechnen mit dem Datensatz und wir l√∂sen sie wieder auf.\n\nmonthly_means <- ungroup(monthly_means)\n\nUm die monatlichen Daten als Zeitreihen zu plotten, brauchen wir noch eine Variable mit dem dazugeh√∂rigen Datum. Die Funktion parse_date_time() kann aus character richtige Datums- und Zeitobjekte erstellen. Sie ist allgemeiner als die oben verwendete ymd_h() Funktion, da man hier das Format explizit angeben kann. In unserem Fall ist das Format ‚Äòym‚Äô f√ºr Jahr und Monat.\n\nmonthly_means <- monthly_means %>%\n  mutate(year_month = parse_date_time(paste0(year, month), orders = 'ym', tz = 'CET'))\n\nmonthly_means\n\n\n\n  \n\n\n\nDer Code paste0(year, month) ‚Äúklebt‚Äù die Daten in der Variablen year und month zusammen. Das ist n√∂tig, da die Funktion parse_date_time() einen zusammenh√§ngenden Text als Input erwartet und keine zwei getrennten Spalten. Da das Datum au√üer dem Jahr und dem Monat noch einen Tag braucht, hat parse_date_time() automatisch den Ersten eines jeden Monats genommen. Beim Erstellen von korrekten Zeitangaben kommt es auch auf die Zeitzone an. Wir sind in Deutschland, da gilt die mitteleurop√§ische Zeit (engl. central European time, CET). Die Zeitzone ist f√ºr unsere Daten zwar nicht wirklich relevant, da wir hier Monatsdaten darstellen. Ich w√ºrde sie aber trotzdem richtig setzten, da die Standardeinstellung der Funktion parse_date_time(tz = \"UTC\") lautet und f√ºr Deutschland falsch ist.\n\nggplot(data = monthly_means, aes(x = year_month, y = mean_T, col = factor(STATIONS_ID))) + \n  geom_line() + \n  labs(x = 'Zeit', y = 'Temperatur (¬∞C)', color = 'Messstation')\n\n\n\n\nAlternativ k√∂nnen wir die Mittelwerte mit den Standardabweichungen darstellen.\n\nggplot(monthly_means, aes(x = year_month, y = mean_T, ymin = mean_T - sd_T, ymax = mean_T + sd_T)) +\n  geom_errorbar() +\n  geom_point() +\n  facet_wrap(~STATIONS_ID, nrow = 3) + \n  labs(x = 'Zeit', y = 'Temperatur (¬∞C)')\n\n\n\n\nOder, weil es gerade Spa√ü macht, als halb-transparentes Band üòé.\n\nggplot(monthly_means, aes(x = year_month, y = mean_T, ymin = mean_T - sd_T, ymax = mean_T + sd_T)) +\n  geom_ribbon(alpha = 0.5) +\n  geom_line() +\n  facet_wrap(~STATIONS_ID, nrow = 3) + \n  labs(x = 'Zeit', y = 'Temperatur (¬∞C)')\n\n\n\n\nEin letzter Trick. Die √úberschriften f√ºr die Teilgrafiken sind ungeschickt, da man die IDs als Mensch einfach nicht zuordnen kann. Weiter oben haben wir einen benannten Vektor definiert, der die Klarnamen enth√§lt.\n\nstation_ids\n\n       2261        1420        2667 \n      \"Hof\" \"Frankfurt\"     \"Koeln\" \n\n\nDiesen Vektor nutzen wir als Titel.\n\nggplot(monthly_means, aes(x = year_month, y = mean_T, ymin = mean_T - sd_T, ymax = mean_T + sd_T)) +\n  geom_ribbon(alpha = 0.5) +\n  geom_line() +\n  facet_wrap(~STATIONS_ID, nrow = 3, labeller = labeller(STATIONS_ID = station_ids)) + \n  labs(x = 'Zeit', y = 'Temperatur (¬∞C)')"
  },
  {
    "objectID": "06-explorative-numerisch.html#weiterf√ºhrende-literatur-und-videos",
    "href": "06-explorative-numerisch.html#weiterf√ºhrende-literatur-und-videos",
    "title": "6¬† Exploration von numerischen Daten",
    "section": "6.5 Weiterf√ºhrende Literatur und Videos",
    "text": "6.5 Weiterf√ºhrende Literatur und Videos\n\nR4DS Wickham and Grolemund (2021): Kapitel 5 ‚ÄúData transformation‚Äù\nEine live Analyse des Hauptautors von tidyverse, Hadley Wickham. Empfehlenswert, auch wenn er viel zu schnell tippt üòÑ."
  },
  {
    "objectID": "06-explorative-numerisch.html#aufgaben",
    "href": "06-explorative-numerisch.html#aufgaben",
    "title": "6¬† Exploration von numerischen Daten",
    "section": "6.6 Aufgaben",
    "text": "6.6 Aufgaben\n\n6.6.1 Was bedeutet der Code?\nWas bedeuten die Parameter ymin und ymax im folgenden Code?\n\nggplot(monthly_means, aes(x = year_month, y = mean_T, ymin = mean_T - sd_T, ymax = mean_T + sd_T))\n\n\n\n6.6.2 Welche Mittelwerte machen Sinn?\nDiskutieren Sie kritisch, welche mittleren Jahrestemperaturen Sinn machen und interpretiert werden k√∂nnen. Begr√ºnden Sie.\n\n\n6.6.3 Politbarometer\nBearbeiten Sie die Aufgaben Section¬†A.3.1 und Section¬†A.4.1 aus der Aufgabensammlung."
  },
  {
    "objectID": "06-explorative-numerisch.html#ihre-arbeit-einreichen",
    "href": "06-explorative-numerisch.html#ihre-arbeit-einreichen",
    "title": "6¬† Exploration von numerischen Daten",
    "section": "6.7 Ihre Arbeit einreichen",
    "text": "6.7 Ihre Arbeit einreichen\n\nSpeichern Sie Ihr Notebook ab.\nLaden Sie Ihre .Rmd Datei in ILIAS hoch. Beachten Sie die Frist!\nSie erhalten die Musterl√∂sung nach dem Hochladen.\n\n\n\n\n\nWickham, Hadley, and Garrett Grolemund. 2021. R for Data Science. https://r4ds.had.co.nz/."
  },
  {
    "objectID": "100-aufgabensammlung.html#exploration-von-numerischen-daten",
    "href": "100-aufgabensammlung.html#exploration-von-numerischen-daten",
    "title": "Appendix A ‚Äî Aufgabensammlung",
    "section": "A.5 Exploration von numerischen Daten",
    "text": "A.5 Exploration von numerischen Daten\n\nA.5.1 Umweltdaten entlang der d√§nischen K√ºste\nDie Datei ‚ÄúTemperatur.csv‚Äù aus Zuur, Ieno, and Meesters (2009b) enth√§lt Messungen von Temperatur, Salinit√§t und Chlorophyll a an 31 Orten entlang der d√§nischen K√ºste. Der Datensatz kann hier heruntergeladen werden. Sie bekommen ihn aber bereits √ºber ILIAS gestellt. Die Daten stammen vom d√§nischen Institut RIKZ (Monitoringprogramm MWTL: Monitoring Waterstaatkundige Toestand des Lands). Die Messungen wurden zwischen 1990 und 2005 durchgef√ºhrt, mit einer H√§ufigkeit von 0‚Äì4 mal pro Monat je nach Jahreszeit.\n\nLesen Sie den Datensatz ‚ÄúTemperatur.csv‚Äù (auf ILIAS) ein.\nKonvertieren Sie die Spalte Date in ein richtiges Datumsformat und plotten Sie die Temperaturen pro Station (facet_wrap()) als Zeitreihen.\nBerechnen Sie die Anzahl der Messwerte, Monatsmittelwerte der Temperatur f√ºr alle Stationen, sowie die Standardabweichungen. Tipp: innerhalb von summarize() m√ºssen Sie n = n() schreiben, um die Anzahl der Messwerte zu erhalten.\nStellen Sie die Monatsmittel der Temperatur als Linien dar. Tipp: Um die Monate mit ihren Namen darzustellen, nutzen Sie den folgenden Code scale_x_discrete(limits = as_factor(1:12), labels = month.abb). H√§ngen Sie ihn mit einem + an. Was macht dieser Code?\nBeschriften Sie die Grafik sinnvoll.\nF√ºgen Sie die Standardabweichungen als Band hinzu.\n\n\n\nA.5.2 Quantile\nWir besch√§ftigen uns mit dem Datensatz possum im Paket openintro.\n\nLaden Sie die Biblothek und anschlie√üend den Datensatz.\nBerechnen Sie\n\n\nDas 1. Quartil\nDas 3. Quartil\nDen Median\n\nDer K√∂rper- und Kopfl√§ngen.\n\nStellen Sie die K√∂rper- und Kopfl√§ngen als Boxplots nebeneinander dar. Nutzen Sie dazu die Bibliothek patchwork.\nStellen Sie die beiden Variablen als Streudiagramm dar (K√∂rperl√§ngen auf die \\(x\\)-Achse).\nBerechnen Sie den linearen Korrelationskoeffizienten mit der Funktion cor().\n\n\n\n\n\nZuur, A. F., E. Ieno, and E. Meesters. 2009a. A Beginner‚Äôs Guide to R. Springer.\n\n\n‚Äî‚Äî‚Äî. 2009b. A Beginner‚Äôs Guide to R. Springer."
  },
  {
    "objectID": "07-lineare-regression.html",
    "href": "07-lineare-regression.html",
    "title": "7¬† Lineare Regression",
    "section": "",
    "text": "Allgemeinen Aufbau eines Regressionsmodells erkl√§ren.\nLineare Regression mit einer und mehreren erkl√§renden Variablen selbst in R durchf√ºhren.\nParameter des linearen Regressionsmodells interpretieren."
  },
  {
    "objectID": "07-lineare-regression.html#begriff-regression",
    "href": "07-lineare-regression.html#begriff-regression",
    "title": "7¬† Lineare Regression",
    "section": "7.1 Begriff Regression",
    "text": "7.1 Begriff Regression\nWoher kommt der Begriff Regression? Diesen pr√§gte Sir Francis Galton (1822-1911) (Fahrmeir, Kneib, and Lang 2009). Galton interessierte sich unter anderem f√ºr den Zusammenhang zwischen der durchschnittlichen K√∂rpergr√∂√üe der Eltern und der K√∂rpergr√∂√üe ihrer erwachsenen Kinder. Leider war er nicht nur einer der V√§ter der Statistik, sondern auch ein Rassist.\nGalton stellte fest, dass Kinder von unterdurchschnittlich kleinen Eltern eher gr√∂√üer waren und umgekehrt, Kinder von √ºberdurchschnittlich gro√üen Eltern eher kleiner waren. Diesen Effekt nannte er Regression (R√ºckkehr) zur Mitte."
  },
  {
    "objectID": "07-lineare-regression.html#idee-der-regression",
    "href": "07-lineare-regression.html#idee-der-regression",
    "title": "7¬† Lineare Regression",
    "section": "7.2 Idee der Regression",
    "text": "7.2 Idee der Regression\nDie Regression ist ein Modell, dass einen Zusammenhang zwischen Variablen analysiert. Wenn dieser Zusammenhang linear ist, dann nennt man das Modell lineare Regression. Wir werden uns ausschlie√ülich mit solchen linearen Modellen besch√§ftigen.\nDie lineare Regression untersucht also den linearen Zusammenhang zwischen den sogen. erkl√§renden Variablen und der Zielvariablen. Im historischen Beispiel von Galton gab es nur eine erkl√§rende Variable, n√§mlich die Durchschnittsgr√∂√üe der Eltern. Die Zielvariable war die zu erwartende Gr√∂√üe der Kinder. Es ging also nicht darum, die exakte Gr√∂√üe eines bestimmten Kindes zu berechnen, sondern den Einfluss der Durchschnittsgr√∂√üe der Eltern auf die zu erwartende (oder eben mittlere) Gr√∂√üe der Kinder. Es ging also nicht um bestimmte Eltern-Kind-Paare.\nDie Zielvariable muss nicht immer stetig wie die K√∂rpergr√∂√üe sein. Sie kann bin√§r, kategorial oder eine Z√§hlvariable sein. Auch die erkl√§renden Variablen k√∂nnen stetig, bin√§r oder kategorial sein. Das macht die Regressionsmodelle sehr divers. Wir werden uns im Wesentlichen mit numerischen Zielvariablen besch√§ftigen."
  },
  {
    "objectID": "07-lineare-regression.html#lineare-regression-mit-einer-erkl√§renden-variablen",
    "href": "07-lineare-regression.html#lineare-regression-mit-einer-erkl√§renden-variablen",
    "title": "7¬† Lineare Regression",
    "section": "7.3 Lineare Regression mit einer erkl√§renden Variablen",
    "text": "7.3 Lineare Regression mit einer erkl√§renden Variablen\nDie Formel f√ºr die lineare Regression mit einer erkl√§renden Variablen haben Sie bereits in der Vorlesung kennengelernt:\n\n\\(y=b_0+b_1 \\cdot x+e\\)\n\n\\(y\\): Zielvariable (engl. outcome)\n\\(x\\): erkl√§rende Variable oder Pr√§diktor (engl. predictor)\n\\(b_0\\): \\(y\\)-Achsenabschnitt\n\\(b_1\\): Steigung der Geraden\n\\(e\\): Fehlerterm\n\n\nWir nutzen den Datensatz penguins aus dem Paket palmerpenguins, um das lineare Modell mit einer erkl√§renden Variablen anzupassen. Unsere Forschungsfrage lautet:\nK√∂nnen wir aus der K√∂rpermasse der Pinguine deren mittlere Fl√ºgell√§nge vorhersagen?\nAls Erstes m√ºssen wir untersuchen, ob es √ºberhaupt einen plausiblen linearen Zusammenhang zwischen K√∂rpermassen und Fl√ºgell√§ngen gibt. Dazu stellen wir die beiden Variablen in einem Streudiagramm dar. Dabei wird die erkl√§rende Variable auf der \\(x\\)-Achse und die Zielvariable auf der \\(y\\)-Achse dargestellt.\n\nggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values (geom_point).\n\n\n\n\n\nBei diesem Bild kann man von einem linearen Zusammenhang ausgehen. Wir k√∂nnen f√ºr die Visualisierung gleich die Gerade hinzu plotten. Das √ºbernimmt das geom_smooth. Allerdings wird hier die Gerade lediglich dargestellt, die Modellparameter werden nicht gespeichert. Der Parameter method = 'lm' zeigt, dass wir eine Gerade plotten wollen und se = FALSE verhindert das Darstellen der Konfidenzintervalle (das werden wir erst sp√§ter kennenlernen).\n\nggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n  geom_point() +\n  geom_smooth(method = 'lm', se = FALSE)\n\n`geom_smooth()` using formula 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (stat_smooth).\n\n\nWarning: Removed 2 rows containing missing values (geom_point).\n\n\n\n\n\n\n7.3.1 Anpassen des Modells\nUm das lineare Modell anzupassen und danach die Parameter interpretieren zu k√∂nnen, nutzen wir die Funktion lm(). Das steht f√ºr engl. linear model.\n\nmod <- lm(formula = flipper_length_mm ~ body_mass_g, data = penguins, na.action = na.exclude)\n\nDer Parameter des Aufrufs ist wie folgt:\n\nformula = flipper_length_mm ~ body_mass_g: Das ist die Geradengleichung, die wir anpassen wollen. Die Struktur ist \\(y ~ x\\), also Zielvariable ~ Pr√§diktor. Man kann formula = weggelassen und gleich flipper_length_mm ~ body_mass_g schreiben.\ndata = penguins: Datensatz, in dem die Variablen zu finden sind\nna.action = na.exclude: Die fehlenden Werte sollen f√ºr die Modellierung ignoriert werden.\n\n\n\n7.3.2 Modellparameter\nDie Modellergebnisse haben wir dem Objekt mod zugeordnet. Das enth√§lt sowohl die Modellparameter als auch die Residuen und die angepassten Werte. Die Modellparameter sind der \\(y\\)-Achsenabschnitt (engl. intercept) und die Steigun der Geraden. Die Funktion tidy()aus dem Paket broom() sorgt f√ºr ein sch√∂nes Layout der Tabelle:\n\nmod %>% \n  tidy()\n\n\n\n  \n\n\n\nDer \\(y\\)-Achsenabschnitt ist also 136,7 mm und die Steigung 0,02 mm/g. Um die anderen Spalten k√ºmmern wir uns im weiteren Verlauf des Kurses.\n\n\n7.3.3 Residualplot\nAls N√§chstes m√ºssen wir √ºberpr√ºfen, ob die Residuen in unserem Modell irgendwelche auff√§lligen Muster zeigen. Das w√§re ein Hinweis darauf, dass wir entweder ein falsches Modell (z. B. linear statt nicht-linear) angepasst oder evtl. eine erkl√§rende Variable nicht ber√ºcksichtigt haben.\nDie Residuen werden in einem sogen. Residualplot dargestellt. Dabei werde auf der \\(x\\)-Achse die vom Modell angepassten Werte, d.¬†h. die Werte auf der Geraden, dargestellt, und auf der \\(y\\)-Achse die Residuen. Um den Aufruf zu ggplot() zu vereinfachen, speichern wir die Residuen und die angepassten Werte direkt im Datensatz penguins mithilfe von `mutate().\n\npenguins <- penguins %>% \n  mutate(residuals = residuals(mod),\n         fitted = fitted(mod))\n\nDer Residualplot sieht wie folgt aus:\n\nggplot(data = penguins, mapping = aes(x = fitted, y = residuals)) +\n  geom_point() +\n  geom_hline(yintercept = 0) +\n  labs(x = 'Angepasste Werte', y = 'Residuen')\n\nWarning: Removed 2 rows containing missing values (geom_point).\n\n\n\n\n\nMan bekommt eine Warnung, dass der Datensatz 2 Fehlwerte enth√§lt. Die Streuung der Residuen sieht gleich aus f√ºr den gesamten Bereich der angepassten Werte und es sind keine Muster zu erkennen. Es spricht also daf√ºr, dass das Modell soweit plausibel f√ºr unsere Daten ist.\n\n\n7.3.4 Wie gut ist das Modell?\nDer Determinationskoeffizient \\(R^2\\) ist ein G√ºtema√ü f√ºr das angepasste Modell. Er zeigt, wie viel Variabilit√§t der Zielvariablen, hier also der Fl√ºgell√§ngen, wird vom Modell erkl√§rt. Mit anderen Worten, wenn wir das Modell verwenden und die Information √ºber die K√∂rpermasse der Tiere nutzen, um wie viel sinkt dann die Variabilit√§t unserer Vorhersagen der Fl√ºgell√§ngen.\nDen Determinationskoeffizienten \\(R^2\\) k√∂nnen wir mit der Funktion glance() anzeigen lassen. Er steht gleich in der ersten Spalte r.squred.\n\nmod %>%\n  glance()\n\n\n\n  \n\n\n\nDer Determinationskoeffizient ist gerundet 0.76. Das bedeutet, dass unser Modell ca. 76% der Variabilit√§t der Fl√ºgell√§ngen erkl√§rt. Es ist ein sehr gutes Modell.\n\n\n7.3.5 Interpretation der Modellparameter\nDie Steigung des linearen Modells beschreibt, um wie viel die durchschnittliche Fl√ºgell√§nge sich √§ndert, wenn die K√∂rpermasse des Tieres um eine Einheit (also ein g) steigt. Der \\(y\\)-Achsenabschnitt beschreibt die durchschnittliche Fl√ºgell√§nge, wenn die K√∂rpermasse 0 ist. Das ist keine relevante Gr√∂√üe, da K√∂rpermassen von 0 nicht beobachtet werden. Allerdings darf man den \\(y\\)-Achsenabschnitt nicht einfach weglassen, da sonst die Gerade nicht optimal an die Daten angepasst wird."
  },
  {
    "objectID": "07-lineare-regression.html#aufgaben",
    "href": "07-lineare-regression.html#aufgaben",
    "title": "7¬† Lineare Regression",
    "section": "7.4 Aufgaben",
    "text": "7.4 Aufgaben\n\n7.4.1 Vertiefung des linearen Modells\nArbeiten Sie das Tutorial Regression modeling: 4 - Interpreting regression models durch.\n\n\n7.4.2 Vorhersagen\nNachdem Sie das Tutorial durchgearbeitet haben, nutzen Sie Ihr neues Wissen, und\n\nBerechnen Sie f√ºr einen Pinguin mit der K√∂rpermasse 5000 g die zu erwartende Fl√ºgell√§nge. Tipp: new_data <- data.frame(body_mass_g = 5000).\nStellen Sie diesen vorhergesagten Wert dar. Tipp: Nutzen Sie die Funktion augment(). Es sollte die folgende Abbildung dabei entstehen:"
  },
  {
    "objectID": "07-lineare-regression.html#ihre-arbeit-einreichen",
    "href": "07-lineare-regression.html#ihre-arbeit-einreichen",
    "title": "7¬† Lineare Regression",
    "section": "7.5 Ihre Arbeit einreichen",
    "text": "7.5 Ihre Arbeit einreichen\n\nSpeichern Sie Ihr Notebook ab.\nLaden Sie Ihre .Rmd Datei in ILIAS hoch. Beachten Sie die Frist!\nSie erhalten die Musterl√∂sung nach dem Hochladen.\n\n\n\n\n\nFahrmeir, L., T. Kneib, and S. Lang. 2009. Regression. Springer. http://link.springer.com/book/10.1007/978-3-642-01837-4."
  },
  {
    "objectID": "07-lineare-regression-ein-pred.html",
    "href": "07-lineare-regression-ein-pred.html",
    "title": "7¬† Lineare Regression mit einer erkl√§renden Variablen",
    "section": "",
    "text": "Allgemeinen Aufbau eines Regressionsmodells erkl√§ren.\nLineare Regression mit einer erkl√§renden Variablen selbst in R durchf√ºhren.\nParameter des linearen Regressionsmodells interpretieren."
  },
  {
    "objectID": "07-lineare-regression-ein-pred.html#begriff-regression",
    "href": "07-lineare-regression-ein-pred.html#begriff-regression",
    "title": "7¬† Lineare Regression mit einer erkl√§renden Variablen",
    "section": "7.1 Begriff Regression",
    "text": "7.1 Begriff Regression\nWoher kommt der Begriff Regression? Diesen pr√§gte Sir Francis Galton (1822-1911) (Fahrmeir, Kneib, and Lang 2009). Galton interessierte sich unter anderem f√ºr den Zusammenhang zwischen der durchschnittlichen K√∂rpergr√∂√üe der Eltern und der K√∂rpergr√∂√üe ihrer erwachsenen Kinder. Leider war er nicht nur einer der V√§ter der Statistik, sondern auch ein Rassist.\nGalton stellte fest, dass Kinder von unterdurchschnittlich kleinen Eltern eher gr√∂√üer waren und umgekehrt, Kinder von √ºberdurchschnittlich gro√üen Eltern eher kleiner waren. Diesen Effekt nannte er Regression (R√ºckkehr) zur Mitte."
  },
  {
    "objectID": "07-lineare-regression-ein-pred.html#idee-der-regression",
    "href": "07-lineare-regression-ein-pred.html#idee-der-regression",
    "title": "7¬† Lineare Regression mit einer erkl√§renden Variablen",
    "section": "7.2 Idee der Regression",
    "text": "7.2 Idee der Regression\nDie Regression ist ein Modell, dass einen Zusammenhang zwischen Variablen analysiert. Wenn dieser Zusammenhang linear ist, dann nennt man das Modell lineare Regression. Wir werden uns ausschlie√ülich mit solchen linearen Modellen besch√§ftigen.\nDie lineare Regression untersucht also den linearen Zusammenhang zwischen den sogen. erkl√§renden Variablen und der Zielvariablen. Im historischen Beispiel von Galton gab es nur eine erkl√§rende Variable, n√§mlich die Durchschnittsgr√∂√üe der Eltern. Die Zielvariable war die zu erwartende Gr√∂√üe der Kinder. Es ging also nicht darum, die exakte Gr√∂√üe eines bestimmten Kindes zu berechnen, sondern den Einfluss der Durchschnittsgr√∂√üe der Eltern auf die zu erwartende (oder eben mittlere) Gr√∂√üe der Kinder. Es ging also nicht um bestimmte Eltern-Kind-Paare.\nDie Zielvariable muss nicht immer stetig wie die K√∂rpergr√∂√üe sein. Sie kann bin√§r, kategorial oder eine Z√§hlvariable sein. Auch die erkl√§renden Variablen k√∂nnen stetig, bin√§r oder kategorial sein. Das macht die Regressionsmodelle sehr divers. Wir werden uns im Wesentlichen mit numerischen Zielvariablen besch√§ftigen."
  },
  {
    "objectID": "07-lineare-regression-ein-pred.html#lineare-regression-mit-einer-numerischen-erkl√§renden-variablen",
    "href": "07-lineare-regression-ein-pred.html#lineare-regression-mit-einer-numerischen-erkl√§renden-variablen",
    "title": "7¬† Lineare Regression mit einer erkl√§renden Variablen",
    "section": "7.3 Lineare Regression mit einer numerischen erkl√§renden Variablen",
    "text": "7.3 Lineare Regression mit einer numerischen erkl√§renden Variablen\nDie Formel f√ºr die lineare Regression mit einer erkl√§renden Variablen haben Sie bereits in der Vorlesung kennengelernt:\n\n\\(y=b_0+b_1 \\cdot x+e\\)\n\n\\(y\\): Zielvariable (engl. outcome)\n\\(x\\): erkl√§rende Variable oder Pr√§diktor (engl. predictor)\n\\(b_0\\): \\(y\\)-Achsenabschnitt\n\\(b_1\\): Steigung der Geraden\n\\(e\\): Fehlerterm\n\n\nWir nutzen den Datensatz penguins aus dem Paket palmerpenguins, um das lineare Modell mit einer erkl√§renden Variablen anzupassen. Unsere Forschungsfrage lautet:\nK√∂nnen wir aus der K√∂rpermasse der Pinguine deren mittlere Fl√ºgell√§nge vorhersagen?\nAls Erstes m√ºssen wir untersuchen, ob es √ºberhaupt einen plausiblen linearen Zusammenhang zwischen K√∂rpermassen und Fl√ºgell√§ngen gibt. Dazu stellen wir die beiden Variablen in einem Streudiagramm dar. Dabei wird die erkl√§rende Variable auf der \\(x\\)-Achse und die Zielvariable auf der \\(y\\)-Achse dargestellt.\n\nggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values (geom_point).\n\n\n\n\n\nBei diesem Bild kann man von einem linearen Zusammenhang ausgehen. Wir k√∂nnen f√ºr die Visualisierung gleich die Gerade hinzu plotten. Das √ºbernimmt das geom_smooth. Allerdings wird hier die Gerade lediglich dargestellt, die Modellparameter werden nicht gespeichert. Der Parameter method = 'lm' zeigt, dass wir eine Gerade plotten wollen und se = FALSE verhindert das Darstellen der Konfidenzintervalle (das werden wir erst sp√§ter kennenlernen).\n\nggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) +\n  geom_point() +\n  geom_smooth(method = 'lm', se = FALSE)\n\n`geom_smooth()` using formula 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (stat_smooth).\n\n\nWarning: Removed 2 rows containing missing values (geom_point).\n\n\n\n\n\n\n7.3.1 Anpassen des Modells\nUm das lineare Modell anzupassen und danach die Parameter interpretieren zu k√∂nnen, nutzen wir die Funktion lm(). Das steht f√ºr engl. linear model.\n\nmod <- lm(formula = flipper_length_mm ~ body_mass_g, data = penguins, na.action = na.exclude)\n\nDer Parameter des Aufrufs ist wie folgt:\n\nformula = flipper_length_mm ~ body_mass_g: Das ist die Geradengleichung, die wir anpassen wollen. Die Struktur ist \\(y ~ x\\), also Zielvariable ~ Pr√§diktor. Man kann formula = weggelassen und gleich flipper_length_mm ~ body_mass_g schreiben.\ndata = penguins: Datensatz, in dem die Variablen zu finden sind\nna.action = na.exclude: Die fehlenden Werte sollen f√ºr die Modellierung ignoriert werden.\n\n\n\n7.3.2 Modellparameter\nDie Modellergebnisse haben wir dem Objekt mod zugeordnet. Das enth√§lt sowohl die Modellparameter als auch die Residuen und die angepassten Werte. Die Modellparameter sind der \\(y\\)-Achsenabschnitt (engl. intercept) und die Steigung der Geraden. Die Funktion tidy()aus dem Paket broom() sorgt f√ºr ein sch√∂nes Layout der Tabelle:\n\nmod %>% \n  tidy()\n\n\n\n  \n\n\n\nDer \\(y\\)-Achsenabschnitt ist also 136,7 mm und die Steigung 0,02 mm/g. Um die anderen Spalten k√ºmmern wir uns im weiteren Verlauf des Kurses.\n\n\n7.3.3 Residualplot\nAls N√§chstes m√ºssen wir √ºberpr√ºfen, ob die Residuen in unserem Modell irgendwelche auff√§lligen Muster zeigen. Das w√§re ein Hinweis darauf, dass wir entweder ein falsches Modell (z. B. linear statt nicht-linear) angepasst oder evtl. eine erkl√§rende Variable nicht ber√ºcksichtigt haben.\nDie Residuen werden in einem sogen. Residualplot dargestellt. Dabei werden auf der \\(x\\)-Achse die vom Modell angepassten Werte, d.¬†h. die Werte auf der Geraden, dargestellt, und auf der \\(y\\)-Achse die Residuen. Um den Aufruf zu ggplot() zu vereinfachen, speichern wir die Residuen und die angepassten Werte direkt im Datensatz penguins mithilfe von `mutate().\n\npenguins <- penguins %>% \n  mutate(residuals = residuals(mod),\n         fitted = fitted(mod))\n\nDer Residualplot sieht wie folgt aus:\n\nggplot(data = penguins, mapping = aes(x = fitted, y = residuals)) +\n  geom_point() +\n  geom_hline(yintercept = 0) +\n  labs(x = 'Angepasste Werte', y = 'Residuen')\n\nWarning: Removed 2 rows containing missing values (geom_point).\n\n\n\n\n\nMan bekommt eine Warnung, dass der Datensatz 2 Fehlwerte enth√§lt. Die Streuung der Residuen sieht gleich aus f√ºr den gesamten Bereich der angepassten Werte und es sind keine Muster zu erkennen. Es spricht also daf√ºr, dass das Modell soweit plausibel f√ºr unsere Daten ist.\n\n\n7.3.4 Wie gut ist das Modell?\nDer Determinationskoeffizient \\(R^2\\) ist ein G√ºtema√ü f√ºr das angepasste Modell. Er zeigt, wie viel Variabilit√§t der Zielvariablen, hier also der Fl√ºgell√§ngen, wird vom Modell erkl√§rt. Mit anderen Worten, wenn wir das Modell verwenden und die Information √ºber die K√∂rpermasse der Tiere nutzen, um wie viel sinkt dann die Variabilit√§t unserer Vorhersagen der Fl√ºgell√§ngen.\nDen Determinationskoeffizienten \\(R^2\\) k√∂nnen wir mit der Funktion glance() anzeigen lassen. Er steht gleich in der ersten Spalte r.squred.\n\nmod %>%\n  glance()\n\n\n\n  \n\n\n\nDer Determinationskoeffizient ist gerundet 0.76. Das bedeutet, dass unser Modell ca. 76% der Variabilit√§t der Fl√ºgell√§ngen erkl√§rt. Es ist ein sehr gutes Modell.\n\n\n7.3.5 Interpretation der Modellparameter\nDie Steigung des linearen Modells beschreibt, um wie viel die durchschnittliche Fl√ºgell√§nge sich √§ndert, wenn die K√∂rpermasse des Tieres um eine Einheit (also ein g) steigt. Der \\(y\\)-Achsenabschnitt beschreibt die durchschnittliche Fl√ºgell√§nge, wenn die K√∂rpermasse 0 ist. Das ist keine relevante Gr√∂√üe, da K√∂rpermassen von 0 nicht beobachtet werden. Allerdings darf man den \\(y\\)-Achsenabschnitt nicht einfach weglassen, da sonst die Gerade nicht optimal an die Daten angepasst wird."
  },
  {
    "objectID": "07-lineare-regression-ein-pred.html#aufgaben",
    "href": "07-lineare-regression-ein-pred.html#aufgaben",
    "title": "7¬† Lineare Regression mit einer erkl√§renden Variablen",
    "section": "7.4 Aufgaben",
    "text": "7.4 Aufgaben\n\n7.4.1 Vertiefung des linearen Modells\nArbeiten Sie das Tutorial Regression modeling: 4 - Interpreting regression models durch.\n\n\n7.4.2 Vorhersagen\nNachdem Sie das Tutorial durchgearbeitet haben, nutzen Sie Ihr neues Wissen, und\n\nBerechnen Sie f√ºr einen Pinguin mit der K√∂rpermasse 5000 g die zu erwartende Fl√ºgell√§nge. Tipp: new_data <- data.frame(body_mass_g = 5000).\nStellen Sie diesen vorhergesagten Wert dar. Tipp: Nutzen Sie die Funktion augment(). Es sollte die folgende Abbildung dabei entstehen:"
  },
  {
    "objectID": "07-lineare-regression-ein-pred.html#ihre-arbeit-einreichen",
    "href": "07-lineare-regression-ein-pred.html#ihre-arbeit-einreichen",
    "title": "7¬† Lineare Regression mit einer erkl√§renden Variablen",
    "section": "7.5 Ihre Arbeit einreichen",
    "text": "7.5 Ihre Arbeit einreichen\n\nSpeichern Sie Ihr Notebook ab.\nLaden Sie Ihre .Rmd Datei in ILIAS hoch. Beachten Sie die Frist!\nSie erhalten die Musterl√∂sung nach dem Hochladen.\n\n\n\n\n\nFahrmeir, L., T. Kneib, and S. Lang. 2009. Regression. Springer. http://link.springer.com/book/10.1007/978-3-642-01837-4."
  },
  {
    "objectID": "index.html#lernergebnisse-intended-learning-outcomes",
    "href": "index.html#lernergebnisse-intended-learning-outcomes",
    "title": "√úbung zur Vorlesung Statistik und Datenanalyse",
    "section": "Lernergebnisse (intended learning outcomes)",
    "text": "Lernergebnisse (intended learning outcomes)\n\nDatenanalyse\n\nDaten f√ºr statistische Analysen aufbereiten\nExplorative (beschreibende) Datenanalyse durchf√ºhren\nDaten visualisieren\nErgebnisse der Analysen reproduzierbar darstellen\n\nStatistische Methoden\n\nEinfache statistische Kenngr√∂√üen (Mittelwert, Standardabweichung etc.) berechnen\nEine Korrelation zwischen zwei Datens√§tzen berechnen\nHypothesentests durchf√ºhren und die Ergebnisse richtig berichten und interpretieren\nKonfidenzintervalle berechnen und interpretieren\nEin lineares Modell berechnen, die Ergebnisse darstellen und interpretieren"
  },
  {
    "objectID": "index.html#was-mir-im-umgang-miteinander-wichtig-ist",
    "href": "index.html#was-mir-im-umgang-miteinander-wichtig-ist",
    "title": "√úbung zur Vorlesung Statistik und Datenanalyse",
    "section": "Was mir im Umgang miteinander wichtig ist",
    "text": "Was mir im Umgang miteinander wichtig ist\n\nP√ºnktlichkeit bei Pr√§senz- und Zoomsitzungen\nGute Vorbereitung durch Erledigen der Hausaufgaben\nRespektieren anderer Meinungen\nOffenheit gegen√ºber neuen Sichtweisen, Themen und Methoden\nGeduld mit sich selbst und den anderen üòÑ"
  },
  {
    "objectID": "index.html#sinn-und-unsinn-dieses-skripts",
    "href": "index.html#sinn-und-unsinn-dieses-skripts",
    "title": "√úbung zur Vorlesung Statistik und Datenanalyse",
    "section": "Sinn und Unsinn dieses Skripts",
    "text": "Sinn und Unsinn dieses Skripts\nDieses Skript ist ein lebendiges Begleitdokument des Kurses. Es wird laufend angepasst und aktualisiert.\nIch nutze verschiedenfarbige Bl√∂cke, um wichtige Stellen hervorzuheben:\n\nInfoblock\n\n\n\nAchtung, wichtig!\n\n\n\nDefinition\n\n\n\nLernziele"
  },
  {
    "objectID": "index.html#inspiration-quellen-und-danksagung",
    "href": "index.html#inspiration-quellen-und-danksagung",
    "title": "√úbung zur Vorlesung Statistik und Datenanalyse",
    "section": "Inspiration, Quellen und Danksagung",
    "text": "Inspiration, Quellen und Danksagung\nDieses Skript baut stark auf folgenden freien Quellen auf:\n\nr4ds: Wickham and Grolemund (2021)\nggplot2: Wickham (2020)\nModernDive: Ismay and Kim (2021)\nIntroduction to Modern Statistics: √áetinkaya-Rundel and Hardin (2022)\n\nDen Autoren dieser B√ºcher gilt ein gro√üer Dank f√ºr Ihren Beitrag zur -Community !"
  },
  {
    "objectID": "index.html#reproduzierbarkeit",
    "href": "index.html#reproduzierbarkeit",
    "title": "√úbung zur Vorlesung Statistik und Datenanalyse",
    "section": "Reproduzierbarkeit",
    "text": "Reproduzierbarkeit\nDieses Skript wurde in RStudio mit Quarto geschrieben und in R version 4.2.2 Patched (2022-11-10 r83330) gebaut. Folgende Pakete werden f√ºr die Beispiele und √úbungen ben√∂tigt:\n\n\n\n\n\n\n\n\n\n\n\n\npackage\nversion\nsource\n\n\n\n\ndabestr\n0.3.0\nGithub (ACCLAB/dabestr@8775899f7eba743a6a32bd2fdab5f57e79401fd6)\n\n\nemojifont\n0.5.5\nCRAN (R 4.2.0)\n\n\nfontawesome\n0.3.0\nCRAN (R 4.2.1)\n\n\ngapminder\n0.3.0\nCRAN (R 4.2.2)\n\n\ninfer\n1.0.3\nCRAN (R 4.2.2)\n\n\nlubridate\n1.8.0\nCRAN (R 4.2.0)\n\n\nmoderndive\n0.5.3\nCRAN (R 4.2.0)\n\n\ntidyverse\n1.3.1\nCRAN (R 4.2.0)\n\n\n\n\nDie komplette Information zur Session lautet:\n\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.1 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/atlas/libblas.so.3.10.3\nLAPACK: /usr/lib/x86_64-linux-gnu/atlas/liblapack.so.3.10.3\n\nlocale:\n [1] LC_CTYPE=de_DE.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=de_DE.UTF-8        LC_COLLATE=de_DE.UTF-8    \n [5] LC_MONETARY=de_DE.UTF-8    LC_MESSAGES=de_DE.UTF-8   \n [7] LC_PAPER=de_DE.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=de_DE.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.13   knitr_1.39        magrittr_2.0.3    R6_2.5.1         \n [5] rlang_1.0.6       fastmap_1.1.0     fansi_1.0.3       highr_0.9        \n [9] stringr_1.4.0     tools_4.2.2       xfun_0.31         sessioninfo_1.2.2\n[13] utf8_1.2.2        cli_3.4.1         ellipsis_0.3.2    htmltools_0.5.2  \n[17] yaml_2.3.5        digest_0.6.29     assertthat_0.2.1  rprojroot_2.0.3  \n[21] lifecycle_1.0.3   tibble_3.1.7      fontawesome_0.3.0 crayon_1.5.1     \n[25] purrr_0.3.4       vctrs_0.5.1       htmlwidgets_1.5.4 glue_1.6.2       \n[29] evaluate_0.15     rmarkdown_2.14    emo_0.0.0.9000    stringi_1.7.6    \n[33] pillar_1.7.0      compiler_4.2.2    desc_1.4.1        generics_0.1.2   \n[37] jsonlite_1.8.0    lubridate_1.8.0   pkgconfig_2.0.3  \n\n\n\nDieses Skript ist lizenziert unter Creative Commons Namensnennung - Nicht-kommerziell - Weitergabe unter gleichen Bedingungen 4.0 International.\n\n\n\n\n√áetinkaya-Rundel, Mine, and Johanna Hardin. 2022. Introduction to Modern Statistics. https://openintro-ims.netlify.app/.\n\n\nIsmay, Chester, and Albert Y. Kim. 2021. ModernDive: Statistical Inference via Data Science. https://moderndive.com/.\n\n\nWickham, Hadley. 2020. Ggplot2: Elegant Graphics for Data Analysis. 3rd, in progress.\n\n\nWickham, Hadley, and Garrett Grolemund. 2021. R for Data Science. https://r4ds.had.co.nz/."
  },
  {
    "objectID": "09-tests-infer.html#workflow-in-infer",
    "href": "09-tests-infer.html#workflow-in-infer",
    "title": "8¬† Hypothesentests mit Randomisierung",
    "section": "8.2 Workflow in infer",
    "text": "8.2 Workflow in infer\nDas Paket infer bietet ein einheitliches Framework f√ºr Hypothesentests (Figure¬†8.1). Es hat 4 Verben, die den oben beschriebenen Prozess der Hypothesentests vereinheitlichen und ein Verb f√ºr die Visualisierung der Ergebnisse:\n\nspecify() Variablen festlegen\nhypothesize() Nullhypothese definieren\ngenerate() Daten unter der Nullhypothese generieren\ncalculate() Stichprobenverteilung (d.h. Verteilung der Teststatistik) berechnen\nvisualize() Stichprobenverteilung darstellen\n\nMit get_p_value kann man den \\(p\\)-Wert berechnen und mit shade_p_value diesen darstellen lassen.\n\n\n\nFigure¬†8.1: Allgemeines Vorgehen bei Hypothesentests (Quelle: https://infer.netlify.app/)."
  },
  {
    "objectID": "09-tests-infer.html#aufgaben",
    "href": "09-tests-infer.html#aufgaben",
    "title": "8¬† Hypothesentests mit Randomisierung",
    "section": "8.4 Aufgaben",
    "text": "8.4 Aufgaben\n\n8.4.1 Vertiefung des Themas Zufall und Variabilit√§t\nArbeiten Sie das Tutorial Foundations of inference: 1 - Sampling Variability durch."
  },
  {
    "objectID": "09-tests-infer.html#studiendauer-in-werdeschlau",
    "href": "09-tests-infer.html#studiendauer-in-werdeschlau",
    "title": "8¬† Hypothesentests mit Randomisierung",
    "section": "8.1 Studiendauer in Werdeschlau",
    "text": "8.1 Studiendauer in Werdeschlau\nWir besch√§ftigen uns mit einem fiktiven Beispiel.\nAn der (kleinen) Universit√§t Werdeschlau m√∂chte man wissen, ob die vor einiger Zeit eingef√ºhrte Studienordnung die Studiendauer ver√§ndert hat. Dazu werden 300 Studierende zuf√§llig √ºber die Dauer ihres Studiums befragt. Zus√§tzlich werden noch andere Daten erhoben, aber mit diesen besch√§ftigen wir uns in einer andern √úbung.\n\n8.1.1 Simulation der Grundgesamtheit\nBei statistischer Inferenz geht es unter anderem darum, die Begriffe Zufall und Variabilit√§t zu quantifizieren. Um diese Konzepte zu verstehen, helfen Computerexperimente. Daf√ºr erstellen wir uns unsere eigene Grundgesamtheit aller Studierenden an der Universit√§t Werdeschlau. Das hat den Vorteil, dass wir viele verschiedene Befragungen durchf√ºhren k√∂nnen, die Variabilit√§t der Antworten analysieren und dabei immer mit den wahren Parametern der Grundgesamtheit vergleichen k√∂nnen.\nWir erstellen zun√§chst die Grundgesamtheit. Die Zeile set.seed(123) sorgt f√ºr reproduzierbare Ergebnisse.\n\nset.seed(123)\n\npop_size <- 12000\nstudent_id <- 1:pop_size\n  \nanreise <- c(runif(n = pop_size * 0.8, min = 5, max = 40),\n             runif(n = pop_size * 0.2, min = 60, max = 120))\n\ngeschlecht <- sample(c('m', 'w'), size = pop_size, replace = TRUE)\n\nstudienordnung <- sample(c('alt', 'neu'), size = pop_size, replace = TRUE)\n\nwohnort <- sapply(anreise, function(x) {\n  if(x < 30) 'stadt'\n  else 'land'\n})\n\nstudiendauer <- rnorm(n = pop_size, mean = 3.5, sd = 0.6)\n\nWir setzen geschlecht, wohnort, studiendauer, studienordnung und anreise zu einer Datenmatrix (tibble) zusammen und nennen das Objekt grundgesamtheit.\n\ngrundgesamtheit <- tibble(geschlecht, wohnort, studiendauer, studienordnung, anreise)\n\n\n\n8.1.2 Befragung simulieren\nIn der Realit√§t werden nat√ºrlich nicht alle 12000 Studierende befragt (wer hat schon so viele Kapazit√§ten?), sondern eine zuf√§llige Stichprobe erhoben, also eine Teilmenge der Grundgesamtheit.\nUm unsere Stichprobe zu erstellen, ziehen wir 300 Studierende ohne Zur√ºcklegen aus unserer Grundgesamtheit. Das entspricht einer einmaligen Befragung von 300 zuf√§llig ausgew√§hlten Studierenden.\n\nset.seed(345)\n\nbefragung_size <- 300\n\nbefragung <- rep_sample_n(grundgesamtheit, size = befragung_size, replace = FALSE, reps = 1)\n\nWir berechnen den Mittelwert der Studiendauer, jeweils f√ºr die alte und neue Studienordnung.\n\nstat_obs <- befragung %>% \n  group_by(studienordnung) %>% \n  summarise(dauer = mean(studiendauer))\n\nstat_obs\n\n\n\n  \n\n\n\nWie gro√ü ist die Differenz der Mittelwerte?\n\nstat_obs$dauer[1] - stat_obs$dauer[2]\n\n[1] -0.1183631\n\n\nWie ver√§ndert sich die Differenz, wenn wir zuf√§lligerweise andere Studierende befragt h√§tten? Wir w√§hlen neue Studierende aus und wiederholen die Berechnung des Mittelwerts der Studiendauer.\n\nset.seed(987)\n\nbefragung <- rep_sample_n(grundgesamtheit, size = befragung_size, replace = FALSE, reps = 1)\n\nstat_obs <- befragung %>% \n  group_by(studienordnung) %>% \n  summarise(dauer = mean(studiendauer))\n\nstat_obs\n\n\n\n  \n\n\n\nF√ºr diese Gruppe der Befragten betr√§gt die Differenz der Mittelwerte 0.0323477."
  },
  {
    "objectID": "09-tests-infer.html#hypothesentest-durchf√ºhren",
    "href": "09-tests-infer.html#hypothesentest-durchf√ºhren",
    "title": "8¬† Hypothesentests mit Randomisierung",
    "section": "8.3 Hypothesentest durchf√ºhren",
    "text": "8.3 Hypothesentest durchf√ºhren\n\n8.3.1 Schritt 1: Nullhypothese und Alternativhypothese festlegen\nUnsere Forschungsfrage lautet: Hat sich die Studiendauer durch die Einf√ºhrung der neuen Studienordnung ver√§ndert? Daraus ergeben sich folgende Hypothesen:\n\nNullhypothese H\\(_0\\): Die Studiendauer hat sich durch die Einf√ºhrung der neuen Studienordnung nicht ver√§ndert. Sie ist gleich geblieben.\nAlternativhypothese H\\(_A\\): Die Studiendauer hat sich durch die Einf√ºhrung der neuen Studienordnung ver√§ndert.\n\nDie Alternativhypothese ist unsere eigentliche Forschungsfrage. Da wir nicht wissen, in welche Richtung die √Ñnderungen erfolgt sein k√∂nnte (Verl√§ngerung oder Verk√ºrzung der Studiendauer), formulieren wir eine sogenannte beidseitige Alternativhypothese. Beidseitig hei√üt, dass √Ñnderungen in beide Richtungen interessant sind.\nWir berechnen zun√§chst die tats√§chlich in den Daten (der Befragung) beobachtete Differenz zwischen den Studiendauern nach der alten und der neuen Studienordnung, also unsere Teststatistik. Die Differenz wird als alt \\(-\\) neu berechnet. Die Funktion observe() im Paket infer berechnet diese Teststatistik.\n\nd_hat <- befragung %>% \n  observe(formula = studiendauer ~ studienordnung,\n          stat = \"diff in means\", \n          order = c('alt', 'neu'))\n\nd_hat\n\n\n\n  \n\n\n\n\n\n8.3.2 Schritt 2: Simulationsexperimente durchf√ºhren\nUm Daten unter der Nullhypothese, d.¬†h. wenn die Nullhypothese gilt, zu produzieren, permutieren wir 10000 Mal die Variable studienordnung. Denn, wenn die Studiendauer nicht von der Studienordnung abh√§ngt, dann sind diese beiden Variablen unabh√§ngig. Das legt die Zeile hypothesize(null = \"independence\") fest.\n\nnull_dist <- befragung %>%\n  specify(studiendauer ~ studienordnung) %>%\n  hypothesize(null = \"independence\") %>%\n  generate(reps = 10000, type = \"permute\") %>%\n  calculate(stat = \"diff in means\", order = c('alt', 'neu'))\n\n\n\n8.3.3 Schritt 3: Ergebnisse darstellen\nWir stellen die Verteilung der Teststatistiken unter der Nullhypothese als ein Histogramm dar und zeichnen zus√§tzlich ein, wo sich die beobachtete Teststatistik (d.¬†h. der beobachtete Unterschied der Mittelwerte) befindet als vertikale rote Linie. Die schattierten Bereiche zeigen Teststatistiken aus den Permutationen, die so extrem oder noch extremer sind, als die beobachtete Teststatistik von 0.0323477. Da unsere Alternativhypothese lautet, dass sich die Studiendauer ver√§ndert hat, betrachten wir extreme Werte sowohl bei der Verl√§ngerung als auch bei der Verk√ºrzung der Studiendauer als Evidenz gegen die Nullhypothese und zugunsten der Alternativhypothese. Daher f√§rben wird die Bereiche links und spiegelbildlich rechts der beobachteten Teststatistik ein.\n\nvisualize(null_dist) +\n  shade_p_value(obs_stat = d_hat, direction = \"two-sided\")\n\n\n\n\n\n\n8.3.4 Schritt 4: \\(p\\)-Wert berechnen und Schlussfolgerungen ziehen\nDer folgende Code berechnet den \\(p\\)-Wert. Der \\(p\\)-Wert gibt uns die Wahrscheinlichkeit an, eine Teststatistik (also die Differenz der Mittelwerte) so extrem oder noch extremer als 0.0323477 zu beobachten, wenn die Nullhypothese tats√§chlich korrekt ist. In anderen Worten, wenn wir in infer Daten generieren unter der Nullhypothese (d.¬†h. √ºbereinstimmend mit der Nullhypothese), dann kommt eine Differenz von 0.0323477 oder noch gr√∂√üer und spiegelbildlich von -0.0323477 oder noch kleiner mit einer Wahrscheinlichkeit von \\(p\\) vor. Um den \\(p\\)-Wert zu berechnen, rechnen wir den Anteil der eingef√§rbten Bereiche aus.\n\nnull_dist %>%\n  get_p_value(obs_stat = d_hat, direction = \"two-sided\")\n\n\n\n  \n\n\n\nWir sehen also, dass Differenzen zwischen den Mittelwerten von 0.0323477 oder noch gr√∂√üer oder und spiegelbildlich von -0.0323477 oder noch kleiner in 63.18% der F√§lle vorkommen, wenn die Nullhypothese gilt. So eine Differenz ist also nichts Besonderes. Unser Signifikanzniveau ist \\(\\alpha = 0.05\\). Da \\(p > \\alpha\\), behalten wir die Nullhypothese bei. Es gibt also keinen Unterschied in der Studiendauer zwischen der alten und der neuen Studienordnung."
  }
]